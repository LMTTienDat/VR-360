{"ast":null,"code":"/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar Map = require('./collections/Map');\nvar Set = require('./collections/Set');\nvar LruSet = require('./collections/LruSet');\nvar eventEmitter = require('minimal-event-emitter');\nvar defaults = require('./util/defaults');\nvar retry = require('./util/retry');\nvar chain = require('./util/chain');\nvar inherits = require('./util/inherits');\nvar clearOwnProperties = require('./util/clearOwnProperties');\nvar debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.textureStore;\n\n// A Stage informs the TextureStore about the set of visible tiles during a\n// frame by calling startFrame, markTile and endFrame. In a particular frame,\n// TextureStore expects one or more calls to startFrame, followed by zero or\n// more calls to markTile, followed by one or more calls to endFrame. The\n// number of calls to startFrame and endFrame must match. Calls to other\n// TextureStore methods may be freely interleaved with this sequence.\n//\n// At any given time, TextureStore is in one of four states. The START state\n// corresponds to the interval between the first startFrame and the first\n// markTile of a frame. The MARK state corresponds to the interval between the\n// first markTile and the first endFrame. The END state corresponds to the\n// interval between the first and the last endFrame. At any other time, the\n// TextureStore is in the IDLE state.\nvar State = {\n  IDLE: 0,\n  START: 1,\n  MARK: 2,\n  END: 3\n};\nvar defaultOptions = {\n  // Maximum number of cached textures for previously visible tiles.\n  previouslyVisibleCacheSize: 512\n};\n\n// Assign an id to each operation so we can track its state.\n// We actually only need this in debug mode, but the code is less convoluted\n// if we track unconditionally, and the performance hit is minimal anyway.\nvar nextId = 0;\n\n// Distinguishes a cancellation from other kinds of errors.\nfunction CancelError() {}\ninherits(CancelError, Error);\n\n/**\n * @class TextureStoreItem\n * @classdesc\n *\n * An item saved in a {@link TextureStore}.\n *\n * Clients do not need to instantiate this. It is automatically instantiated by\n * a {@link TextureStore} to manage the lifetime of a stored item: loading,\n * refreshing, unloading and emitting associated events.\n *\n * @param {TextureStore} store The underlying {@link TextureStore}.\n * @param {Tile} tile The underlying tile.\n */\nfunction TextureStoreItem(store, tile) {\n  var self = this;\n  var id = nextId++;\n  self._id = id;\n  self._store = store;\n  self._tile = tile;\n  self._asset = null;\n  self._texture = null;\n  self._changeHandler = function () {\n    store.emit('textureInvalid', tile);\n  };\n  var source = store.source();\n  var stage = store.stage();\n  var loadAsset = source.loadAsset.bind(source);\n  var createTexture = stage.createTexture.bind(stage);\n\n  // Retry loading the asset until it succeeds, then create the texture from it.\n  // This process may be canceled at any point by calling the destroy() method.\n  var fn = chain(retry(loadAsset), createTexture);\n  store.emit('textureStartLoad', tile);\n  if (debug) {\n    console.log('loading', id, tile);\n  }\n  self._cancel = fn(stage, tile, function (err, _tile, asset, texture) {\n    // Make sure we do not call cancel after the operation is complete.\n    self._cancel = null;\n    if (err) {\n      // The loading process was interrupted by an error.\n      // This could either be because the texture creation failed, or because\n      // the operation was canceled before the loading was complete.\n\n      // Destroy the asset and texture, if they exist.\n      if (asset) {\n        asset.destroy();\n      }\n      if (texture) {\n        texture.destroy();\n      }\n\n      // Emit events.\n      if (err instanceof CancelError) {\n        store.emit('textureCancel', tile);\n        if (debug) {\n          console.log('cancel', id, tile);\n        }\n      } else {\n        store.emit('textureError', tile, err);\n        if (debug) {\n          console.log('error', id, tile);\n        }\n      }\n      return;\n    }\n\n    // Save a local reference to the texture.\n    self._texture = texture;\n\n    // If the asset is dynamic, save a local reference to it and set up a\n    // handler to be called whenever it changes. Otherwise, destroy the asset\n    // as we won't be needing it any longer.\n    if (asset.isDynamic()) {\n      self._asset = asset;\n      asset.addEventListener('change', self._changeHandler);\n    } else {\n      asset.destroy();\n    }\n\n    // Emit event.\n    store.emit('textureLoad', tile);\n    if (debug) {\n      console.log('load', id, tile);\n    }\n  });\n}\nTextureStoreItem.prototype.asset = function () {\n  return this._asset;\n};\nTextureStoreItem.prototype.texture = function () {\n  return this._texture;\n};\nTextureStoreItem.prototype.destroy = function () {\n  var id = this._id;\n  var store = this._store;\n  var tile = this._tile;\n  var asset = this._asset;\n  var texture = this._texture;\n  var cancel = this._cancel;\n  if (cancel) {\n    // The texture is still loading, so cancel it.\n    cancel(new CancelError('Texture load cancelled'));\n    return;\n  }\n\n  // Destroy asset.\n  if (asset) {\n    asset.removeEventListener('change', this._changeHandler);\n    asset.destroy();\n  }\n\n  // Destroy texture.\n  if (texture) {\n    texture.destroy();\n  }\n\n  // Emit event.\n  store.emit('textureUnload', tile);\n  if (debug) {\n    console.log('unload', id, tile);\n  }\n  clearOwnProperties(this);\n};\neventEmitter(TextureStoreItem);\n\n/**\n * Signals that a texture has started to load.\n *\n * This event is followed by either {@link TextureStore#textureLoad},\n * {@link TextureStore#textureError} or {@link TextureStore#textureCancel}.\n *\n * @event TextureStore#textureStartLoad\n * @param {Tile} tile The tile for which the texture has started to load.\n */\n\n/**\n * Signals that a texture has been loaded.\n *\n * @event TextureStore#textureLoad\n * @param {Tile} tile The tile for which the texture was loaded.\n */\n\n/**\n * Signals that a texture has been unloaded.\n *\n * @event TextureStore#textureUnload\n * @param {Tile} tile The tile for which the texture was unloaded.\n */\n\n/**\n * Signals that a texture has been invalidated.\n *\n * This event may be raised for a texture with an underlying dynamic asset. It\n * may only occur while the texture is loaded, i.e., in between\n * {@link TextureStore#textureLoad} and {@link TextureStore#textureUnload}.\n *\n * @event TextureStore#textureInvalid\n * @param {Tile} tile The tile for which the texture was invalidated.\n */\n\n/**\n * Signals that loading a texture has been cancelled.\n *\n * This event may follow {@link TextureStore#textureStartLoad} if the texture\n * becomes unnecessary before it finishes loading.\n *\n * @event TextureStore#textureCancel\n * @param {Tile} tile The tile for which the texture loading was cancelled.\n */\n\n/**\n * Signals that loading a texture has failed.\n *\n * This event may follow {@link TextureStore#textureStartLoad} if the texture\n * fails to load.\n *\n * @event TextureStore#textureError\n * @param {Tile} tile The tile for which the texture loading has failed.\n */\n\n/**\n * @class TextureStore\n * @classdesc\n *\n * A TextureStore maintains a cache of textures used to render a {@link Layer}.\n *\n * A {@link Stage} communicates with the TextureStore through the startFrame(),\n * markTile() and endFrame() methods, which indicate the tiles that are visible\n * in the current frame. Textures for visible tiles are loaded and retained\n * as long as the tiles remain visible. A limited amount of textures whose\n * tiles were previously visible are cached according to an LRU policy. Tiles\n * may be pinned to keep their respective textures cached even when they are\n * invisible; these textures do not count towards the previously visible limit.\n *\n * Multiple layers belonging to the same underlying {@link WebGlStage} may\n * share the same TextureStore. Layers belonging to distinct {@link WebGlStage}\n * instances may not do so due to restrictions on the use of textures across\n * stages.\n *\n * @param {Source} source The underlying source.\n * @param {Stage} stage The underlying stage.\n * @param {Object} opts Options.\n * @param {Number} [opts.previouslyVisibleCacheSize=32] The maximum number of\n *     previously visible textures to cache according to an LRU policy.\n */\nfunction TextureStore(source, stage, opts) {\n  opts = defaults(opts || {}, defaultOptions);\n  this._source = source;\n  this._stage = stage;\n\n  // The current state.\n  this._state = State.IDLE;\n\n  // The number of startFrame calls yet to be matched by endFrame calls during\n  // the current frame.\n  this._delimCount = 0;\n\n  // The cache proper: map cached tiles to their respective textures/assets.\n  this._itemMap = new Map();\n\n  // The subset of cached tiles that are currently visible.\n  this._visible = new Set();\n\n  // The subset of cached tiles that were visible recently, but are not\n  // visible right now. Newly inserted tiles replace older ones.\n  this._previouslyVisible = new LruSet(opts.previouslyVisibleCacheSize);\n\n  // The subset of cached tiles that should never be evicted from the cache.\n  // A tile may be pinned more than once; map each tile into a reference count.\n  this._pinMap = new Map();\n\n  // Temporary variables.\n  this._newVisible = new Set();\n  this._noLongerVisible = [];\n  this._visibleAgain = [];\n  this._evicted = [];\n}\neventEmitter(TextureStore);\n\n/**\n * Destructor.\n */\nTextureStore.prototype.destroy = function () {\n  this.clear();\n  clearOwnProperties(this);\n};\n\n/**\n * Return the underlying {@link Stage}.\n * @return {Stage}\n */\nTextureStore.prototype.stage = function () {\n  return this._stage;\n};\n\n/**\n * Return the underlying {@link Source}.\n * @return {Source}\n */\nTextureStore.prototype.source = function () {\n  return this._source;\n};\n\n/**\n * Remove all textures from the TextureStore, including pinned textures.\n */\nTextureStore.prototype.clear = function () {\n  var self = this;\n\n  // Collect list of tiles to be evicted.\n  self._evicted.length = 0;\n  self._itemMap.forEach(function (tile) {\n    self._evicted.push(tile);\n  });\n\n  // Evict tiles.\n  self._evicted.forEach(function (tile) {\n    self._unloadTile(tile);\n  });\n\n  // Clear all internal state.\n  self._itemMap.clear();\n  self._visible.clear();\n  self._previouslyVisible.clear();\n  self._pinMap.clear();\n  self._newVisible.clear();\n  self._noLongerVisible.length = 0;\n  self._visibleAgain.length = 0;\n  self._evicted.length = 0;\n};\n\n/**\n * Remove all textures in the TextureStore, excluding unpinned textures.\n */\nTextureStore.prototype.clearNotPinned = function () {\n  var self = this;\n\n  // Collect list of tiles to be evicted.\n  self._evicted.length = 0;\n  self._itemMap.forEach(function (tile) {\n    if (!self._pinMap.has(tile)) {\n      self._evicted.push(tile);\n    }\n  });\n\n  // Evict tiles.\n  self._evicted.forEach(function (tile) {\n    self._unloadTile(tile);\n  });\n\n  // Clear all caches except the pinned set.\n  self._visible.clear();\n  self._previouslyVisible.clear();\n\n  // Clear temporary variables.\n  self._evicted.length = 0;\n};\n\n/**\n * Signal the beginning of a frame. Called from {@link Stage}.\n */\nTextureStore.prototype.startFrame = function () {\n  // Check that we are in an appropriate state.\n  if (this._state !== State.IDLE && this._state !== State.START) {\n    throw new Error('TextureStore: startFrame called out of sequence');\n  }\n\n  // Enter the START state, if not already there.\n  this._state = State.START;\n\n  // Expect one more endFrame call.\n  this._delimCount++;\n};\n\n/**\n * Mark a tile as visible within the current frame. Called from {@link Stage}.\n * @param {Tile} tile The tile to mark.\n */\nTextureStore.prototype.markTile = function (tile) {\n  // Check that we are in an appropriate state.\n  if (this._state !== State.START && this._state !== State.MARK) {\n    throw new Error('TextureStore: markTile called out of sequence');\n  }\n\n  // Enter the MARK state, if not already there.\n  this._state = State.MARK;\n\n  // Refresh texture for dynamic assets.\n  var item = this._itemMap.get(tile);\n  var texture = item && item.texture();\n  var asset = item && item.asset();\n  if (texture && asset) {\n    texture.refresh(tile, asset);\n  }\n\n  // Add tile to the visible set.\n  this._newVisible.add(tile);\n};\n\n/**\n * Signal the end of a frame. Called from {@link Stage}.\n */\nTextureStore.prototype.endFrame = function () {\n  // Check that we are in an appropriate state.\n  if (this._state !== State.START && this._state !== State.MARK && this._state !== State.END) {\n    throw new Error('TextureStore: endFrame called out of sequence');\n  }\n\n  // Enter the END state, if not already there.\n  this._state = State.END;\n\n  // Expect one less call to endFrame.\n  this._delimCount--;\n\n  // If no further calls are expected, process frame and enter the IDLE state.\n  if (!this._delimCount) {\n    this._update();\n    this._state = State.IDLE;\n  }\n};\nTextureStore.prototype._update = function () {\n  var self = this;\n\n  // Calculate the set of tiles that used to be visible but no longer are.\n  self._noLongerVisible.length = 0;\n  self._visible.forEach(function (tile) {\n    if (!self._newVisible.has(tile)) {\n      self._noLongerVisible.push(tile);\n    }\n  });\n\n  // Calculate the set of tiles that were visible recently and have become\n  // visible again.\n  self._visibleAgain.length = 0;\n  self._newVisible.forEach(function (tile) {\n    if (self._previouslyVisible.has(tile)) {\n      self._visibleAgain.push(tile);\n    }\n  });\n\n  // Remove tiles that have become visible again from the list of previously\n  // visible tiles.\n  self._visibleAgain.forEach(function (tile) {\n    self._previouslyVisible.remove(tile);\n  });\n\n  // Cancel loading of tiles that are no longer visible.\n  // Move no longer visible tiles with a loaded texture into the previously\n  // visible set, and collect the tiles evicted from the latter.\n  self._evicted.length = 0;\n  self._noLongerVisible.forEach(function (tile) {\n    var item = self._itemMap.get(tile);\n    var texture = item && item.texture();\n    if (texture) {\n      var otherTile = self._previouslyVisible.add(tile);\n      if (otherTile != null) {\n        self._evicted.push(otherTile);\n      }\n    } else if (item) {\n      self._unloadTile(tile);\n    }\n  });\n\n  // Unload evicted tiles, unless they are pinned.\n  self._evicted.forEach(function (tile) {\n    if (!self._pinMap.has(tile)) {\n      self._unloadTile(tile);\n    }\n  });\n\n  // Load visible tiles that are not already in the store.\n  // Refresh texture on visible tiles for dynamic assets.\n  self._newVisible.forEach(function (tile) {\n    var item = self._itemMap.get(tile);\n    if (!item) {\n      self._loadTile(tile);\n    }\n  });\n\n  // Swap the old visible set with the new one.\n  var tmp = self._visible;\n  self._visible = self._newVisible;\n  self._newVisible = tmp;\n\n  // Clear the new visible set.\n  self._newVisible.clear();\n\n  // Clear temporary variables.\n  self._noLongerVisible.length = 0;\n  self._visibleAgain.length = 0;\n  self._evicted.length = 0;\n};\nTextureStore.prototype._loadTile = function (tile) {\n  if (this._itemMap.has(tile)) {\n    throw new Error('TextureStore: loading texture already in cache');\n  }\n  var item = new TextureStoreItem(this, tile);\n  this._itemMap.set(tile, item);\n};\nTextureStore.prototype._unloadTile = function (tile) {\n  var item = this._itemMap.del(tile);\n  if (!item) {\n    throw new Error('TextureStore: unloading texture not in cache');\n  }\n  item.destroy();\n};\nTextureStore.prototype.asset = function (tile) {\n  var item = this._itemMap.get(tile);\n  if (item) {\n    return item.asset();\n  }\n  return null;\n};\nTextureStore.prototype.texture = function (tile) {\n  var item = this._itemMap.get(tile);\n  if (item) {\n    return item.texture();\n  }\n  return null;\n};\n\n/**\n * Pin a tile. Textures for pinned tiles are never evicted from the store.\n * Upon pinning, the texture is created if not already present. Pins are\n * reference-counted; a tile may be pinned multiple times and must be unpinned\n * the corresponding number of times. Pinning is useful e.g. to ensure that\n * the lowest-resolution level of an image is always available to fall back\n * onto.\n * @param {Tile} tile the tile to pin\n * @returns {number} the pin reference count.\n */\nTextureStore.prototype.pin = function (tile) {\n  // Increment reference count.\n  var count = (this._pinMap.get(tile) || 0) + 1;\n  this._pinMap.set(tile, count);\n  // If the texture for the tile is not present, load it now.\n  if (!this._itemMap.has(tile)) {\n    this._loadTile(tile);\n  }\n  return count;\n};\n\n/**\n * Unpin a tile. Pins are reference-counted; a tile may be pinned multiple\n * times and must be unpinned the corresponding number of times.\n * @param {Tile} tile the tile to unpin\n * @returns {number} the pin reference count.\n */\nTextureStore.prototype.unpin = function (tile) {\n  var count = this._pinMap.get(tile);\n  // Consistency check.\n  if (!count) {\n    throw new Error('TextureStore: unpin when not pinned');\n  } else {\n    // Decrement reference count.\n    count--;\n    if (count > 0) {\n      this._pinMap.set(tile, count);\n    } else {\n      this._pinMap.del(tile);\n      // If the tile does not belong to either the visible or previously\n      // visible sets, evict it from the cache.\n      if (!this._visible.has(tile) && !this._previouslyVisible.has(tile)) {\n        this._unloadTile(tile);\n      }\n    }\n  }\n  return count;\n};\n\n/**\n * Return type for {@link TextureStore#query}.\n * @typedef {Object} TileState\n * @property {boolean} visible Whether the tile is in the visible set.\n * @property {boolean} previouslyVisible Whether the tile is in the previously\n *     visible set.\n * @property {boolean} hasAsset Whether the asset for the tile is present.\n * @property {boolean} hasTexture Whether the texture for the tile is present.\n * @property {boolean} pinned Whether the tile is in the pinned set.\n * @property {number} pinCount The pin reference count for the tile.\n */\n\n/**\n * Return the state of a tile.\n * @param {Tile} tile The tile to query.\n * @return {TileState}\n */\nTextureStore.prototype.query = function (tile) {\n  var item = this._itemMap.get(tile);\n  var pinCount = this._pinMap.get(tile) || 0;\n  return {\n    visible: this._visible.has(tile),\n    previouslyVisible: this._previouslyVisible.has(tile),\n    hasAsset: item != null && item.asset() != null,\n    hasTexture: item != null && item.texture() != null,\n    pinned: pinCount !== 0,\n    pinCount: pinCount\n  };\n};\nmodule.exports = TextureStore;","map":{"version":3,"names":["Map","require","Set","LruSet","eventEmitter","defaults","retry","chain","inherits","clearOwnProperties","debug","MARZIPANODEBUG","textureStore","State","IDLE","START","MARK","END","defaultOptions","previouslyVisibleCacheSize","nextId","CancelError","Error","TextureStoreItem","store","tile","self","id","_id","_store","_tile","_asset","_texture","_changeHandler","emit","source","stage","loadAsset","bind","createTexture","fn","console","log","_cancel","err","asset","texture","destroy","isDynamic","addEventListener","prototype","cancel","removeEventListener","TextureStore","opts","_source","_stage","_state","_delimCount","_itemMap","_visible","_previouslyVisible","_pinMap","_newVisible","_noLongerVisible","_visibleAgain","_evicted","clear","length","forEach","push","_unloadTile","clearNotPinned","has","startFrame","markTile","item","get","refresh","add","endFrame","_update","remove","otherTile","_loadTile","tmp","set","del","pin","count","unpin","query","pinCount","visible","previouslyVisible","hasAsset","hasTexture","pinned","module","exports"],"sources":["E:/VR/node_modules/marzipano/src/TextureStore.js"],"sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar Map = require('./collections/Map');\nvar Set = require('./collections/Set');\nvar LruSet = require('./collections/LruSet');\nvar eventEmitter = require('minimal-event-emitter');\nvar defaults = require('./util/defaults');\nvar retry = require('./util/retry');\nvar chain = require('./util/chain');\nvar inherits = require('./util/inherits');\nvar clearOwnProperties = require('./util/clearOwnProperties');\n\nvar debug = typeof MARZIPANODEBUG !== 'undefined' && MARZIPANODEBUG.textureStore;\n\n\n// A Stage informs the TextureStore about the set of visible tiles during a\n// frame by calling startFrame, markTile and endFrame. In a particular frame,\n// TextureStore expects one or more calls to startFrame, followed by zero or\n// more calls to markTile, followed by one or more calls to endFrame. The\n// number of calls to startFrame and endFrame must match. Calls to other\n// TextureStore methods may be freely interleaved with this sequence.\n//\n// At any given time, TextureStore is in one of four states. The START state\n// corresponds to the interval between the first startFrame and the first\n// markTile of a frame. The MARK state corresponds to the interval between the\n// first markTile and the first endFrame. The END state corresponds to the\n// interval between the first and the last endFrame. At any other time, the\n// TextureStore is in the IDLE state.\nvar State = {\n  IDLE: 0,\n  START: 1,\n  MARK: 2,\n  END: 3\n};\n\n\nvar defaultOptions = {\n  // Maximum number of cached textures for previously visible tiles.\n  previouslyVisibleCacheSize: 512\n};\n\n\n// Assign an id to each operation so we can track its state.\n// We actually only need this in debug mode, but the code is less convoluted\n// if we track unconditionally, and the performance hit is minimal anyway.\nvar nextId = 0;\n\n\n// Distinguishes a cancellation from other kinds of errors.\nfunction CancelError() {}\ninherits(CancelError, Error);\n\n\n/**\n * @class TextureStoreItem\n * @classdesc\n *\n * An item saved in a {@link TextureStore}.\n *\n * Clients do not need to instantiate this. It is automatically instantiated by\n * a {@link TextureStore} to manage the lifetime of a stored item: loading,\n * refreshing, unloading and emitting associated events.\n *\n * @param {TextureStore} store The underlying {@link TextureStore}.\n * @param {Tile} tile The underlying tile.\n */\nfunction TextureStoreItem(store, tile) {\n\n  var self = this;\n\n  var id = nextId++;\n\n  self._id = id;\n  self._store = store;\n  self._tile = tile;\n\n  self._asset = null;\n  self._texture = null;\n\n  self._changeHandler = function() {\n    store.emit('textureInvalid', tile);\n  };\n\n  var source = store.source();\n  var stage = store.stage();\n\n  var loadAsset = source.loadAsset.bind(source);\n  var createTexture = stage.createTexture.bind(stage);\n\n  // Retry loading the asset until it succeeds, then create the texture from it.\n  // This process may be canceled at any point by calling the destroy() method.\n  var fn = chain(retry(loadAsset), createTexture);\n\n  store.emit('textureStartLoad', tile);\n  if (debug) {\n    console.log('loading', id, tile);\n  }\n\n  self._cancel = fn(stage, tile, function(err, _tile, asset, texture) {\n\n    // Make sure we do not call cancel after the operation is complete.\n    self._cancel = null;\n\n    if (err) {\n      // The loading process was interrupted by an error.\n      // This could either be because the texture creation failed, or because\n      // the operation was canceled before the loading was complete.\n\n      // Destroy the asset and texture, if they exist.\n      if (asset) {\n        asset.destroy();\n      }\n      if (texture) {\n        texture.destroy();\n      }\n\n      // Emit events.\n      if (err instanceof CancelError) {\n        store.emit('textureCancel', tile);\n        if (debug) {\n          console.log('cancel', id, tile);\n        }\n      } else {\n        store.emit('textureError', tile, err);\n        if (debug) {\n          console.log('error', id, tile);\n        }\n      }\n\n      return;\n    }\n\n    // Save a local reference to the texture.\n    self._texture = texture;\n\n    // If the asset is dynamic, save a local reference to it and set up a\n    // handler to be called whenever it changes. Otherwise, destroy the asset\n    // as we won't be needing it any longer.\n    if (asset.isDynamic()) {\n      self._asset = asset;\n      asset.addEventListener('change', self._changeHandler);\n    } else {\n      asset.destroy();\n    }\n\n    // Emit event.\n    store.emit('textureLoad', tile);\n    if (debug) {\n      console.log('load', id, tile);\n    }\n  });\n\n}\n\n\nTextureStoreItem.prototype.asset = function() {\n  return this._asset;\n};\n\n\nTextureStoreItem.prototype.texture = function() {\n  return this._texture;\n};\n\n\nTextureStoreItem.prototype.destroy = function() {\n  var id = this._id;\n  var store = this._store;\n  var tile = this._tile;\n  var asset = this._asset;\n  var texture = this._texture;\n  var cancel = this._cancel;\n\n  if (cancel) {\n    // The texture is still loading, so cancel it.\n    cancel(new CancelError('Texture load cancelled'));\n    return;\n  }\n\n  // Destroy asset.\n  if (asset) {\n    asset.removeEventListener('change', this._changeHandler);\n    asset.destroy();\n  }\n\n  // Destroy texture.\n  if (texture) {\n    texture.destroy();\n  }\n\n  // Emit event.\n  store.emit('textureUnload', tile);\n  if (debug) {\n    console.log('unload', id, tile);\n  }\n\n  clearOwnProperties(this);\n};\n\neventEmitter(TextureStoreItem);\n\n/**\n * Signals that a texture has started to load.\n *\n * This event is followed by either {@link TextureStore#textureLoad},\n * {@link TextureStore#textureError} or {@link TextureStore#textureCancel}.\n *\n * @event TextureStore#textureStartLoad\n * @param {Tile} tile The tile for which the texture has started to load.\n */\n\n/**\n * Signals that a texture has been loaded.\n *\n * @event TextureStore#textureLoad\n * @param {Tile} tile The tile for which the texture was loaded.\n */\n\n/**\n * Signals that a texture has been unloaded.\n *\n * @event TextureStore#textureUnload\n * @param {Tile} tile The tile for which the texture was unloaded.\n */\n\n/**\n * Signals that a texture has been invalidated.\n *\n * This event may be raised for a texture with an underlying dynamic asset. It\n * may only occur while the texture is loaded, i.e., in between\n * {@link TextureStore#textureLoad} and {@link TextureStore#textureUnload}.\n *\n * @event TextureStore#textureInvalid\n * @param {Tile} tile The tile for which the texture was invalidated.\n */\n\n/**\n * Signals that loading a texture has been cancelled.\n *\n * This event may follow {@link TextureStore#textureStartLoad} if the texture\n * becomes unnecessary before it finishes loading.\n *\n * @event TextureStore#textureCancel\n * @param {Tile} tile The tile for which the texture loading was cancelled.\n */\n\n/**\n * Signals that loading a texture has failed.\n *\n * This event may follow {@link TextureStore#textureStartLoad} if the texture\n * fails to load.\n *\n * @event TextureStore#textureError\n * @param {Tile} tile The tile for which the texture loading has failed.\n */\n\n/**\n * @class TextureStore\n * @classdesc\n *\n * A TextureStore maintains a cache of textures used to render a {@link Layer}.\n *\n * A {@link Stage} communicates with the TextureStore through the startFrame(),\n * markTile() and endFrame() methods, which indicate the tiles that are visible\n * in the current frame. Textures for visible tiles are loaded and retained\n * as long as the tiles remain visible. A limited amount of textures whose\n * tiles were previously visible are cached according to an LRU policy. Tiles\n * may be pinned to keep their respective textures cached even when they are\n * invisible; these textures do not count towards the previously visible limit.\n *\n * Multiple layers belonging to the same underlying {@link WebGlStage} may\n * share the same TextureStore. Layers belonging to distinct {@link WebGlStage}\n * instances may not do so due to restrictions on the use of textures across\n * stages.\n *\n * @param {Source} source The underlying source.\n * @param {Stage} stage The underlying stage.\n * @param {Object} opts Options.\n * @param {Number} [opts.previouslyVisibleCacheSize=32] The maximum number of\n *     previously visible textures to cache according to an LRU policy.\n */\nfunction TextureStore(source, stage, opts) {\n  opts = defaults(opts || {}, defaultOptions);\n\n  this._source = source;\n  this._stage = stage;\n\n  // The current state.\n  this._state = State.IDLE;\n\n  // The number of startFrame calls yet to be matched by endFrame calls during\n  // the current frame.\n  this._delimCount = 0;\n\n  // The cache proper: map cached tiles to their respective textures/assets.\n  this._itemMap = new Map();\n\n  // The subset of cached tiles that are currently visible.\n  this._visible = new Set();\n\n  // The subset of cached tiles that were visible recently, but are not\n  // visible right now. Newly inserted tiles replace older ones.\n  this._previouslyVisible = new LruSet(opts.previouslyVisibleCacheSize);\n\n  // The subset of cached tiles that should never be evicted from the cache.\n  // A tile may be pinned more than once; map each tile into a reference count.\n  this._pinMap = new Map();\n\n  // Temporary variables.\n  this._newVisible = new Set();\n  this._noLongerVisible = [];\n  this._visibleAgain = [];\n  this._evicted = [];\n}\n\neventEmitter(TextureStore);\n\n\n/**\n * Destructor.\n */\nTextureStore.prototype.destroy = function() {\n  this.clear();\n  clearOwnProperties(this);\n};\n\n\n/**\n * Return the underlying {@link Stage}.\n * @return {Stage}\n */\nTextureStore.prototype.stage = function() {\n  return this._stage;\n};\n\n\n/**\n * Return the underlying {@link Source}.\n * @return {Source}\n */\nTextureStore.prototype.source = function() {\n  return this._source;\n};\n\n\n/**\n * Remove all textures from the TextureStore, including pinned textures.\n */\nTextureStore.prototype.clear = function() {\n  var self = this;\n\n  // Collect list of tiles to be evicted.\n  self._evicted.length = 0;\n  self._itemMap.forEach(function(tile) {\n    self._evicted.push(tile);\n  });\n\n  // Evict tiles.\n  self._evicted.forEach(function(tile) {\n    self._unloadTile(tile);\n  });\n\n  // Clear all internal state.\n  self._itemMap.clear();\n  self._visible.clear();\n  self._previouslyVisible.clear();\n  self._pinMap.clear();\n  self._newVisible.clear();\n  self._noLongerVisible.length = 0;\n  self._visibleAgain.length = 0;\n  self._evicted.length = 0;\n};\n\n\n/**\n * Remove all textures in the TextureStore, excluding unpinned textures.\n */\nTextureStore.prototype.clearNotPinned = function() {\n  var self = this;\n\n  // Collect list of tiles to be evicted.\n  self._evicted.length = 0;\n  self._itemMap.forEach(function(tile) {\n    if (!self._pinMap.has(tile)) {\n      self._evicted.push(tile);\n    }\n  });\n\n  // Evict tiles.\n  self._evicted.forEach(function(tile) {\n    self._unloadTile(tile);\n  });\n\n  // Clear all caches except the pinned set.\n  self._visible.clear();\n  self._previouslyVisible.clear();\n\n  // Clear temporary variables.\n  self._evicted.length = 0;\n};\n\n\n/**\n * Signal the beginning of a frame. Called from {@link Stage}.\n */\nTextureStore.prototype.startFrame = function() {\n  // Check that we are in an appropriate state.\n  if (this._state !== State.IDLE && this._state !== State.START) {\n    throw new Error('TextureStore: startFrame called out of sequence');\n  }\n\n  // Enter the START state, if not already there.\n  this._state = State.START;\n\n  // Expect one more endFrame call.\n  this._delimCount++;\n};\n\n\n/**\n * Mark a tile as visible within the current frame. Called from {@link Stage}.\n * @param {Tile} tile The tile to mark.\n */\nTextureStore.prototype.markTile = function(tile) {\n  // Check that we are in an appropriate state.\n  if (this._state !== State.START && this._state !== State.MARK) {\n    throw new Error('TextureStore: markTile called out of sequence');\n  }\n\n  // Enter the MARK state, if not already there.\n  this._state = State.MARK;\n\n  // Refresh texture for dynamic assets.\n  var item = this._itemMap.get(tile);\n  var texture = item && item.texture();\n  var asset = item && item.asset();\n  if (texture && asset) {\n    texture.refresh(tile, asset);\n  }\n\n  // Add tile to the visible set.\n  this._newVisible.add(tile);\n};\n\n\n/**\n * Signal the end of a frame. Called from {@link Stage}.\n */\nTextureStore.prototype.endFrame = function() {\n  // Check that we are in an appropriate state.\n  if (this._state !== State.START && this._state !== State.MARK && this._state !== State.END) {\n    throw new Error('TextureStore: endFrame called out of sequence');\n  }\n\n  // Enter the END state, if not already there.\n  this._state = State.END;\n\n  // Expect one less call to endFrame.\n  this._delimCount--;\n\n  // If no further calls are expected, process frame and enter the IDLE state.\n  if (!this._delimCount) {\n    this._update();\n    this._state = State.IDLE;\n  }\n};\n\n\nTextureStore.prototype._update = function() {\n  var self = this;\n\n  // Calculate the set of tiles that used to be visible but no longer are.\n  self._noLongerVisible.length = 0;\n  self._visible.forEach(function(tile) {\n    if (!self._newVisible.has(tile)) {\n      self._noLongerVisible.push(tile);\n    }\n  });\n\n  // Calculate the set of tiles that were visible recently and have become\n  // visible again.\n  self._visibleAgain.length = 0;\n  self._newVisible.forEach(function(tile) {\n    if (self._previouslyVisible.has(tile)) {\n      self._visibleAgain.push(tile);\n    }\n  });\n\n  // Remove tiles that have become visible again from the list of previously\n  // visible tiles.\n  self._visibleAgain.forEach(function(tile) {\n    self._previouslyVisible.remove(tile);\n  });\n\n  // Cancel loading of tiles that are no longer visible.\n  // Move no longer visible tiles with a loaded texture into the previously\n  // visible set, and collect the tiles evicted from the latter.\n  self._evicted.length = 0;\n  self._noLongerVisible.forEach(function(tile) {\n    var item = self._itemMap.get(tile);\n    var texture = item && item.texture();\n    if (texture) {\n      var otherTile = self._previouslyVisible.add(tile);\n      if (otherTile != null) {\n        self._evicted.push(otherTile);\n      }\n    } else if (item) {\n      self._unloadTile(tile);\n    }\n  });\n\n  // Unload evicted tiles, unless they are pinned.\n  self._evicted.forEach(function(tile) {\n    if (!self._pinMap.has(tile)) {\n      self._unloadTile(tile);\n    }\n  });\n\n  // Load visible tiles that are not already in the store.\n  // Refresh texture on visible tiles for dynamic assets.\n  self._newVisible.forEach(function(tile) {\n    var item = self._itemMap.get(tile);\n    if (!item) {\n      self._loadTile(tile);\n    }\n  });\n\n  // Swap the old visible set with the new one.\n  var tmp = self._visible;\n  self._visible = self._newVisible;\n  self._newVisible = tmp;\n\n  // Clear the new visible set.\n  self._newVisible.clear();\n\n  // Clear temporary variables.\n  self._noLongerVisible.length = 0;\n  self._visibleAgain.length = 0;\n  self._evicted.length = 0;\n};\n\n\nTextureStore.prototype._loadTile = function(tile) {\n  if (this._itemMap.has(tile)) {\n    throw new Error('TextureStore: loading texture already in cache');\n  }\n  var item = new TextureStoreItem(this, tile);\n  this._itemMap.set(tile, item);\n};\n\n\nTextureStore.prototype._unloadTile = function(tile) {\n  var item = this._itemMap.del(tile);\n  if (!item) {\n    throw new Error('TextureStore: unloading texture not in cache');\n  }\n  item.destroy();\n};\n\n\nTextureStore.prototype.asset = function(tile) {\n  var item = this._itemMap.get(tile);\n  if (item) {\n    return item.asset();\n  }\n  return null;\n};\n\n\nTextureStore.prototype.texture = function(tile) {\n  var item = this._itemMap.get(tile);\n  if (item) {\n    return item.texture();\n  }\n  return null;\n};\n\n\n/**\n * Pin a tile. Textures for pinned tiles are never evicted from the store.\n * Upon pinning, the texture is created if not already present. Pins are\n * reference-counted; a tile may be pinned multiple times and must be unpinned\n * the corresponding number of times. Pinning is useful e.g. to ensure that\n * the lowest-resolution level of an image is always available to fall back\n * onto.\n * @param {Tile} tile the tile to pin\n * @returns {number} the pin reference count.\n */\nTextureStore.prototype.pin = function(tile) {\n  // Increment reference count.\n  var count = (this._pinMap.get(tile) || 0) + 1;\n  this._pinMap.set(tile, count);\n  // If the texture for the tile is not present, load it now.\n  if (!this._itemMap.has(tile)) {\n    this._loadTile(tile);\n  }\n  return count;\n};\n\n\n/**\n * Unpin a tile. Pins are reference-counted; a tile may be pinned multiple\n * times and must be unpinned the corresponding number of times.\n * @param {Tile} tile the tile to unpin\n * @returns {number} the pin reference count.\n */\nTextureStore.prototype.unpin = function(tile) {\n  var count = this._pinMap.get(tile);\n  // Consistency check.\n  if (!count) {\n    throw new Error('TextureStore: unpin when not pinned');\n  } else {\n    // Decrement reference count.\n    count--;\n    if (count > 0) {\n      this._pinMap.set(tile, count);\n    } else {\n      this._pinMap.del(tile);\n      // If the tile does not belong to either the visible or previously\n      // visible sets, evict it from the cache.\n      if (!this._visible.has(tile) && !this._previouslyVisible.has(tile)) {\n        this._unloadTile(tile);\n      }\n    }\n  }\n  return count;\n};\n\n\n/**\n * Return type for {@link TextureStore#query}.\n * @typedef {Object} TileState\n * @property {boolean} visible Whether the tile is in the visible set.\n * @property {boolean} previouslyVisible Whether the tile is in the previously\n *     visible set.\n * @property {boolean} hasAsset Whether the asset for the tile is present.\n * @property {boolean} hasTexture Whether the texture for the tile is present.\n * @property {boolean} pinned Whether the tile is in the pinned set.\n * @property {number} pinCount The pin reference count for the tile.\n */\n\n\n/**\n * Return the state of a tile.\n * @param {Tile} tile The tile to query.\n * @return {TileState}\n */\nTextureStore.prototype.query = function(tile) {\n  var item = this._itemMap.get(tile);\n  var pinCount = this._pinMap.get(tile) || 0;\n  return {\n    visible: this._visible.has(tile),\n    previouslyVisible: this._previouslyVisible.has(tile),\n    hasAsset: item != null && item.asset() != null,\n    hasTexture: item != null && item.texture() != null,\n    pinned: pinCount !== 0,\n    pinCount: pinCount\n  };\n};\n\n\nmodule.exports = TextureStore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}