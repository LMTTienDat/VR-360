{"ast":null,"code":"/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar noop = require('./noop');\n\n// Return a function that executes its arguments (which should be cancelables)\n// in sequence, so that each of them passes its return values to the next.\n// Execution is aborted if one of the functions returns an error; in that case\n// the last function in the sequence is called with the error.\n// See util/cancelize.js for an explanation of what cancelables are.\nfunction chain() {\n  // The list of functions to chain together.\n  var argList = Array.prototype.slice.call(arguments, 0);\n  return function chained() {\n    // List of remaining functions to be executed.\n    // Make a copy of the original list so we can mutate the former while\n    // preserving the latter intact for future invocations of the chain.\n    var fnList = argList.slice(0);\n\n    // Currently executing function.\n    var fn = null;\n\n    // Cancel method for the currently executing function.\n    var cfn = null;\n\n    // Arguments for the first function.\n    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];\n\n    // Callback for the chain.\n    var done = arguments.length ? arguments[arguments.length - 1] : noop;\n\n    // Execute the next function in the chain.\n    // Receives the error and return values from the previous function.\n    function exec() {\n      // Extract error from arguments.\n      var err = arguments[0];\n\n      // Abort chain on error.\n      if (err) {\n        fn = cfn = null;\n        done.apply(null, arguments);\n        return;\n      }\n\n      // Terminate if there are no functions left in the chain.\n      if (!fnList.length) {\n        fn = cfn = null;\n        done.apply(null, arguments);\n        return;\n      }\n\n      // Advance to the next function in the chain.\n      fn = fnList.shift();\n      var _fn = fn;\n\n      // Extract arguments to pass into the next function.\n      var ret = Array.prototype.slice.call(arguments, 1);\n\n      // Call next function with previous return value and call back exec.\n      ret.push(exec);\n      var _cfn = fn.apply(null, ret); // fn(null, ret..., exec)\n\n      // Detect when fn has completed synchronously and do not clobber the\n      // internal state in that case. You're not expected to understand this.\n      if (_fn !== fn) {\n        return;\n      }\n\n      // Remember the cancel method for the currently executing function.\n      // Detect chaining on non-cancellable function.\n      if (typeof _cfn !== 'function') {\n        throw new Error('chain: chaining on non-cancellable function');\n      } else {\n        cfn = _cfn;\n      }\n    }\n\n    // Cancel chain execution.\n    function cancel() {\n      if (cfn) {\n        cfn.apply(null, arguments);\n      }\n    }\n\n    // Start chain execution.\n    // We call exec as if linking from a previous function in the chain,\n    // except that the error is always null. As a consequence, chaining on an\n    // empty list yields the identity function.\n    args.unshift(null);\n    exec.apply(null, args); // exec(null, args...)\n\n    return cancel;\n  };\n}\nmodule.exports = chain;","map":{"version":3,"names":["noop","require","chain","argList","Array","prototype","slice","call","arguments","chained","fnList","fn","cfn","args","length","done","exec","err","apply","shift","_fn","ret","push","_cfn","Error","cancel","unshift","module","exports"],"sources":["E:/VR/node_modules/marzipano/src/util/chain.js"],"sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar noop = require('./noop');\n\n// Return a function that executes its arguments (which should be cancelables)\n// in sequence, so that each of them passes its return values to the next.\n// Execution is aborted if one of the functions returns an error; in that case\n// the last function in the sequence is called with the error.\n// See util/cancelize.js for an explanation of what cancelables are.\nfunction chain() {\n\n  // The list of functions to chain together.\n  var argList = Array.prototype.slice.call(arguments, 0);\n\n  return function chained() {\n\n    // List of remaining functions to be executed.\n    // Make a copy of the original list so we can mutate the former while\n    // preserving the latter intact for future invocations of the chain.\n    var fnList = argList.slice(0);\n\n    // Currently executing function.\n    var fn = null;\n\n    // Cancel method for the currently executing function.\n    var cfn = null;\n\n    // Arguments for the first function.\n    var args = arguments.length ? Array.prototype.slice.call(arguments, 0, arguments.length - 1) : [];\n\n    // Callback for the chain.\n    var done = arguments.length ? arguments[arguments.length - 1] : noop;\n\n    // Execute the next function in the chain.\n    // Receives the error and return values from the previous function.\n    function exec() {\n\n      // Extract error from arguments.\n      var err = arguments[0];\n\n      // Abort chain on error.\n      if (err) {\n        fn = cfn = null;\n        done.apply(null, arguments);\n        return;\n      }\n\n      // Terminate if there are no functions left in the chain.\n      if (!fnList.length) {\n        fn = cfn = null;\n        done.apply(null, arguments);\n        return;\n      }\n\n      // Advance to the next function in the chain.\n      fn = fnList.shift();\n      var _fn = fn;\n\n      // Extract arguments to pass into the next function.\n      var ret = Array.prototype.slice.call(arguments, 1);\n\n      // Call next function with previous return value and call back exec.\n      ret.push(exec);\n      var _cfn = fn.apply(null, ret); // fn(null, ret..., exec)\n\n      // Detect when fn has completed synchronously and do not clobber the\n      // internal state in that case. You're not expected to understand this.\n      if (_fn !== fn) {\n        return;\n      }\n\n      // Remember the cancel method for the currently executing function.\n      // Detect chaining on non-cancellable function.\n      if (typeof _cfn !== 'function') {\n        throw new Error('chain: chaining on non-cancellable function');\n      } else {\n        cfn = _cfn;\n      }\n\n    }\n\n    // Cancel chain execution.\n    function cancel() {\n      if (cfn) {\n        cfn.apply(null, arguments);\n      }\n    }\n\n    // Start chain execution.\n    // We call exec as if linking from a previous function in the chain,\n    // except that the error is always null. As a consequence, chaining on an\n    // empty list yields the identity function.\n    args.unshift(null);\n    exec.apply(null, args); // exec(null, args...)\n\n    return cancel;\n\n  };\n\n}\n\nmodule.exports = chain;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,QAAQ,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA,SAASC,KAAKA,CAAA,EAAG;EAEf;EACA,IAAIC,OAAO,GAAGC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;EAEtD,OAAO,SAASC,OAAOA,CAAA,EAAG;IAExB;IACA;IACA;IACA,IAAIC,MAAM,GAAGP,OAAO,CAACG,KAAK,CAAC,CAAC,CAAC;;IAE7B;IACA,IAAIK,EAAE,GAAG,IAAI;;IAEb;IACA,IAAIC,GAAG,GAAG,IAAI;;IAEd;IACA,IAAIC,IAAI,GAAGL,SAAS,CAACM,MAAM,GAAGV,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,EAAEA,SAAS,CAACM,MAAM,GAAG,CAAC,CAAC,GAAG,EAAE;;IAEjG;IACA,IAAIC,IAAI,GAAGP,SAAS,CAACM,MAAM,GAAGN,SAAS,CAACA,SAAS,CAACM,MAAM,GAAG,CAAC,CAAC,GAAGd,IAAI;;IAEpE;IACA;IACA,SAASgB,IAAIA,CAAA,EAAG;MAEd;MACA,IAAIC,GAAG,GAAGT,SAAS,CAAC,CAAC,CAAC;;MAEtB;MACA,IAAIS,GAAG,EAAE;QACPN,EAAE,GAAGC,GAAG,GAAG,IAAI;QACfG,IAAI,CAACG,KAAK,CAAC,IAAI,EAAEV,SAAS,CAAC;QAC3B;MACF;;MAEA;MACA,IAAI,CAACE,MAAM,CAACI,MAAM,EAAE;QAClBH,EAAE,GAAGC,GAAG,GAAG,IAAI;QACfG,IAAI,CAACG,KAAK,CAAC,IAAI,EAAEV,SAAS,CAAC;QAC3B;MACF;;MAEA;MACAG,EAAE,GAAGD,MAAM,CAACS,KAAK,CAAC,CAAC;MACnB,IAAIC,GAAG,GAAGT,EAAE;;MAEZ;MACA,IAAIU,GAAG,GAAGjB,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;;MAElD;MACAa,GAAG,CAACC,IAAI,CAACN,IAAI,CAAC;MACd,IAAIO,IAAI,GAAGZ,EAAE,CAACO,KAAK,CAAC,IAAI,EAAEG,GAAG,CAAC,CAAC,CAAC;;MAEhC;MACA;MACA,IAAID,GAAG,KAAKT,EAAE,EAAE;QACd;MACF;;MAEA;MACA;MACA,IAAI,OAAOY,IAAI,KAAK,UAAU,EAAE;QAC9B,MAAM,IAAIC,KAAK,CAAC,6CAA6C,CAAC;MAChE,CAAC,MAAM;QACLZ,GAAG,GAAGW,IAAI;MACZ;IAEF;;IAEA;IACA,SAASE,MAAMA,CAAA,EAAG;MAChB,IAAIb,GAAG,EAAE;QACPA,GAAG,CAACM,KAAK,CAAC,IAAI,EAAEV,SAAS,CAAC;MAC5B;IACF;;IAEA;IACA;IACA;IACA;IACAK,IAAI,CAACa,OAAO,CAAC,IAAI,CAAC;IAClBV,IAAI,CAACE,KAAK,CAAC,IAAI,EAAEL,IAAI,CAAC,CAAC,CAAC;;IAExB,OAAOY,MAAM;EAEf,CAAC;AAEH;AAEAE,MAAM,CAACC,OAAO,GAAG1B,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}