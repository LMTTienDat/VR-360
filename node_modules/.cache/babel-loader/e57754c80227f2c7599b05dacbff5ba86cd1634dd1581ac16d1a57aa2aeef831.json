{"ast":null,"code":"/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar eventEmitter = require('minimal-event-emitter');\nvar RenderLoop = require('./RenderLoop');\nvar Controls = require('./controls/Controls');\nvar Scene = require('./Scene');\nvar Timer = require('./Timer');\nvar WebGlStage = require('./stages/WebGl');\nvar ControlCursor = require('./controls/ControlCursor');\nvar HammerGestures = require('./controls/HammerGestures');\nvar registerDefaultControls = require('./controls/registerDefaultControls');\nvar registerDefaultRenderers = require('./renderers/registerDefaultRenderers');\nvar setOverflowHidden = require('./util/dom').setOverflowHidden;\nvar setAbsolute = require('./util/dom').setAbsolute;\nvar setFullSize = require('./util/dom').setFullSize;\nvar tween = require('./util/tween');\nvar noop = require('./util/noop');\nvar clearOwnProperties = require('./util/clearOwnProperties');\n\n/**\n * Signals that the current scene has changed.\n * @event Viewer#sceneChange\n */\n\n/**\n * Signals that the view of the current scene has changed. See\n * {@link View#event:change}.\n * @event Viewer#viewChange\n */\n\n/**\n * @class Viewer\n * @classdesc\n *\n * A Viewer is a container for multiple {@link Scene scenes} to be displayed\n * inside a {@link Stage stage} contained in the DOM.\n *\n * Scenes may be created by calling {@link Viewer#createScene}. Except during a\n * scene switch, a single one of them, called the current scene, is visible.\n * Calling {@link Viewer#switchScene} sets the current scene and switches to it.\n *\n * @param {Element} domElement The DOM element to contain the stage.\n * @param {Object} opts Viewer creation options.\n * @param {Object} opts.controls Options to be passed to\n *     {@link registerDefaultControls}.\n * @param {Object} opts.stage Options to be passed to the {@link Stage}\n *     constructor.\n * @param {Object} opts.cursors Cursor options.\n * @param {Object} opts.cursors.drag Drag cursor options to be passed to the\n *     {@link ControlCursor} constructor.\n */\nfunction Viewer(domElement, opts) {\n  opts = opts || {};\n  this._domElement = domElement;\n\n  // Add `overflow: hidden` to the domElement.\n  setOverflowHidden(domElement);\n\n  // Create stage.\n  this._stage = new WebGlStage(opts.stage);\n\n  // Register the default renderers for the selected stage.\n  registerDefaultRenderers(this._stage);\n\n  // Add the stage element into the DOM.\n  this._domElement.appendChild(this._stage.domElement());\n\n  // Create control container.\n  // Controls cannot be placed directly on the root DOM element because\n  // Hammer.js will prevent click events from reaching the elements beneath.\n\n  // The hotspot containers will be added inside the controls container.\n  this._controlContainer = document.createElement('div');\n  setAbsolute(this._controlContainer);\n  setFullSize(this._controlContainer);\n  domElement.appendChild(this._controlContainer);\n\n  // Respond to window size changes.\n  this._size = {};\n  this.updateSize();\n  this._updateSizeListener = this.updateSize.bind(this);\n  window.addEventListener('resize', this._updateSizeListener);\n\n  // Create render loop.\n  this._renderLoop = new RenderLoop(this._stage);\n\n  // Create the controls and register them with the render loop.\n  this._controls = new Controls();\n  this._controlMethods = registerDefaultControls(this._controls, this._controlContainer, opts.controls);\n  this._controls.attach(this._renderLoop);\n\n  // Expose HammerJS.\n  this._hammerManagerTouch = HammerGestures.get(this._controlContainer, 'touch');\n  this._hammerManagerMouse = HammerGestures.get(this._controlContainer, 'mouse');\n\n  // Initialize drag cursor.\n  this._dragCursor = new ControlCursor(this._controls, 'mouseViewDrag', domElement, opts.cursors && opts.cursors.drag || {});\n\n  // Start the render loop.\n  this._renderLoop.start();\n\n  // Scene list.\n  this._scenes = [];\n\n  // The currently visible scene.\n  // During a scene transition, this is the scene being switched to.\n  this._currentScene = null;\n\n  // The scene being switched from during a scene transition.\n  // This is necessary to update the layers correctly when they are added or\n  // removed during a transition.\n  this._replacedScene = null;\n\n  // The current transition.\n  this._cancelCurrentTween = null;\n\n  // The event listener fired when the current scene layers change.\n  // This is attached to the correct scene whenever the current scene changes.\n  this._layerChangeHandler = this._updateSceneLayers.bind(this);\n\n  // The event listener fired when the current scene view changes.\n  // This is attached to the correct scene whenever the current scene changes.\n  this._viewChangeHandler = this.emit.bind(this, 'viewChange');\n\n  // Setup the idle timer.\n  // By default, the timer has an infinite duration so it does nothing.\n  this._idleTimer = new Timer();\n  this._idleTimer.start();\n\n  // Reset the timer whenever the view changes.\n  this._resetIdleTimerHandler = this._resetIdleTimer.bind(this);\n  this.addEventListener('viewChange', this._resetIdleTimerHandler);\n\n  // Start the idle movement when the idle timer fires.\n  this._triggerIdleTimerHandler = this._triggerIdleTimer.bind(this);\n  this._idleTimer.addEventListener('timeout', this._triggerIdleTimerHandler);\n\n  // Stop an ongoing movement when the controls are activated or when the\n  // scene changes.\n  this._stopMovementHandler = this.stopMovement.bind(this);\n  this._controls.addEventListener('active', this._stopMovementHandler);\n  this.addEventListener('sceneChange', this._stopMovementHandler);\n\n  // The currently programmed idle movement.\n  this._idleMovement = null;\n}\neventEmitter(Viewer);\n\n/**\n * Destructor.\n */\nViewer.prototype.destroy = function () {\n  window.removeEventListener('resize', this._updateSizeListener);\n  if (this._currentScene) {\n    this._removeSceneEventListeners(this._currentScene);\n  }\n  if (this._replacedScene) {\n    this._removeSceneEventListeners(this._replacedScene);\n  }\n  this._dragCursor.destroy();\n  for (var methodName in this._controlMethods) {\n    this._controlMethods[methodName].destroy();\n  }\n  while (this._scenes.length) {\n    this.destroyScene(this._scenes[0]);\n  }\n  this._domElement.removeChild(this._stage.domElement());\n  this._stage.destroy();\n  this._renderLoop.destroy();\n  this._controls.destroy();\n  this._controls = null;\n  if (this._cancelCurrentTween) {\n    this._cancelCurrentTween();\n  }\n  clearOwnProperties(this);\n};\n\n/**\n * Updates the stage size to fill the containing element.\n *\n * This method is automatically called when the browser window is resized.\n * Most clients won't need to explicitly call it to keep the size up to date.\n */\nViewer.prototype.updateSize = function () {\n  var size = this._size;\n  size.width = this._domElement.clientWidth;\n  size.height = this._domElement.clientHeight;\n  this._stage.setSize(size);\n};\n\n/**\n * Returns the underlying {@link Stage stage}.\n * @return {Stage}\n */\nViewer.prototype.stage = function () {\n  return this._stage;\n};\n\n/**\n * Returns the underlying {@link RenderLoop render loop}.\n * @return {RenderLoop}\n */\nViewer.prototype.renderLoop = function () {\n  return this._renderLoop;\n};\n\n/**\n * Returns the underlying {@link Controls controls}.\n * @return {Controls}\n */\nViewer.prototype.controls = function () {\n  return this._controls;\n};\n\n/**\n * Returns the underlying DOM element.\n * @return {Element}\n */\nViewer.prototype.domElement = function () {\n  return this._domElement;\n};\n\n/**\n * Creates a new {@link Scene scene} with a single layer and adds it to the\n * viewer.\n *\n * The current scene does not change. To switch to the scene, call\n * {@link Viewer#switchScene}.\n *\n * @param {Object} opts Scene creation options.\n * @param {View} opts.view The scene's underlying {@link View}.\n * @param {Source} opts.source The layer's underlying {@link Source}.\n * @param {Geometry} opts.geometry The layer's underlying {@link Geometry}.\n * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to\n *     provide a fallback of last resort, at the cost of memory consumption.\n * @param {Object} [opts.textureStoreOpts={}] Options to pass to the\n *     {@link TextureStore} constructor.\n * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}\n *     constructor.\n * @return {Scene}\n */\nViewer.prototype.createScene = function (opts) {\n  opts = opts || {};\n  var scene = this.createEmptyScene({\n    view: opts.view\n  });\n  scene.createLayer({\n    source: opts.source,\n    geometry: opts.geometry,\n    pinFirstLevel: opts.pinFirstLevel,\n    textureStoreOpts: opts.textureStoreOpts,\n    layerOpts: opts.layerOpts\n  });\n  return scene;\n};\n\n/**\n * Creates a new {@link Scene scene} with no layers and adds it to the viewer.\n *\n * Layers may be added to the scene by calling {@link Scene#createLayer}.\n * However, if the scene has a single layer, it is simpler to call\n * {@link Viewer#createScene} instead of this method.\n *\n * The current scene does not change. To switch to the scene, call\n * {@link Viewer#switchScene}.\n *\n * @param {Object} opts Scene creation options.\n * @param {View} opts.view The scene's underlying {@link View}.\n * @return {Scene}\n */\nViewer.prototype.createEmptyScene = function (opts) {\n  opts = opts || {};\n  var scene = new Scene(this, opts.view);\n  this._scenes.push(scene);\n  return scene;\n};\nViewer.prototype._updateSceneLayers = function () {\n  var i;\n  var layer;\n  var stage = this._stage;\n  var currentScene = this._currentScene;\n  var replacedScene = this._replacedScene;\n  var oldLayers = stage.listLayers();\n\n  // The stage contains layers from at most two scenes: the current one, on top,\n  // and the one currently being switched away from, on the bottom.\n  var newLayers = [];\n  if (replacedScene) {\n    newLayers = newLayers.concat(replacedScene.listLayers());\n  }\n  if (currentScene) {\n    newLayers = newLayers.concat(currentScene.listLayers());\n  }\n\n  // A single layer can be added or removed from the scene at a time.\n  if (Math.abs(oldLayers.length - newLayers.length) !== 1) {\n    throw new Error('Stage and scene out of sync');\n  }\n  if (newLayers.length < oldLayers.length) {\n    // A layer was removed.\n    for (i = 0; i < oldLayers.length; i++) {\n      layer = oldLayers[i];\n      if (newLayers.indexOf(layer) < 0) {\n        this._removeLayerFromStage(layer);\n        break;\n      }\n    }\n  }\n  if (newLayers.length > oldLayers.length) {\n    // A layer was added.\n    for (i = 0; i < newLayers.length; i++) {\n      layer = newLayers[i];\n      if (oldLayers.indexOf(layer) < 0) {\n        this._addLayerToStage(layer, i);\n      }\n    }\n  }\n\n  // TODO: When in the middle of a scene transition, call the transition update\n  // function immediately to prevent an added layer from flashing with the wrong\n  // opacity.\n};\n\nViewer.prototype._addLayerToStage = function (layer, i) {\n  // Pin the first level to ensure a fallback while the layer is visible.\n  // Note that this is distinct from the `pinFirstLevel` option passed to\n  // createScene(), which pins the layer even when it's not visible.\n  layer.pinFirstLevel();\n  this._stage.addLayer(layer, i);\n};\nViewer.prototype._removeLayerFromStage = function (layer) {\n  this._stage.removeLayer(layer);\n  layer.unpinFirstLevel();\n  layer.textureStore().clearNotPinned();\n};\nViewer.prototype._addSceneEventListeners = function (scene) {\n  scene.addEventListener('layerChange', this._layerChangeHandler);\n  scene.addEventListener('viewChange', this._viewChangeHandler);\n};\nViewer.prototype._removeSceneEventListeners = function (scene) {\n  scene.removeEventListener('layerChange', this._layerChangeHandler);\n  scene.removeEventListener('viewChange', this._viewChangeHandler);\n};\n\n/**\n * Destroys a {@link Scene scene} and removes it from the viewer.\n * @param {Scene} scene\n */\nViewer.prototype.destroyScene = function (scene) {\n  var i = this._scenes.indexOf(scene);\n  if (i < 0) {\n    throw new Error('No such scene in viewer');\n  }\n  var j;\n  var layers;\n  if (this._currentScene === scene) {\n    // The destroyed scene is the current scene.\n    // Remove event listeners, remove layers from stage and cancel transition.\n    this._removeSceneEventListeners(scene);\n    layers = scene.listLayers();\n    for (j = 0; j < layers.length; j++) {\n      this._removeLayerFromStage(layers[j]);\n    }\n    if (this._cancelCurrentTween) {\n      this._cancelCurrentTween();\n      this._cancelCurrentTween = null;\n    }\n    this._currentScene = null;\n    this.emit('sceneChange');\n  }\n  if (this._replacedScene === scene) {\n    // The destroyed scene is being switched away from.\n    // Remove event listeners and remove layers from stage.\n    this._removeSceneEventListeners(scene);\n    layers = scene.listLayers();\n    for (j = 0; j < layers.length; j++) {\n      this._removeLayerFromStage(layers[j]);\n    }\n    this._replacedScene = null;\n  }\n  this._scenes.splice(i, 1);\n  scene.destroy();\n};\n\n/**\n * Destroys all {@link Scene scenes} and removes them from the viewer.\n */\nViewer.prototype.destroyAllScenes = function () {\n  while (this._scenes.length > 0) {\n    this.destroyScene(this._scenes[0]);\n  }\n};\n\n/**\n * Returns whether the viewer contains a {@link Scene scene}.\n * @param {Scene} scene\n * @return {boolean}\n */\nViewer.prototype.hasScene = function (scene) {\n  return this._scenes.indexOf(scene) >= 0;\n};\n\n/**\n * Returns a list of all {@link Scene scenes}.\n * @return {Scene[]}\n */\nViewer.prototype.listScenes = function () {\n  return [].concat(this._scenes);\n};\n\n/**\n * Returns the current {@link Scene scene}, or null if there isn't one.\n *\n * To change the current scene, call {@link Viewer#switchScene}.\n *\n * @return {Scene}\n */\nViewer.prototype.scene = function () {\n  return this._currentScene;\n};\n\n/**\n * Returns the {@link View view} for the current {@link Scene scene}, or null\n * if there isn't one.\n * @return {View}\n */\nViewer.prototype.view = function () {\n  var scene = this._currentScene;\n  if (scene) {\n    return scene.view();\n  }\n  return null;\n};\n\n/**\n * Tweens the {@link View view} for the current {@link Scene scene}.\n *\n * This method is equivalent to calling {@link Scene#lookTo} on the current\n * scene.\n *\n * @param {Object} opts Options to pass into {@link Scene#lookTo}.\n * @param {function} done Function to call when the tween is complete.\n */\nViewer.prototype.lookTo = function (params, opts, done) {\n  // TODO: is it an error to call lookTo when no scene is displayed?\n  var scene = this._currentScene;\n  if (scene) {\n    scene.lookTo(params, opts, done);\n  }\n};\n\n/**\n * Starts a movement, possibly replacing the current movement.\n *\n * This method is equivalent to calling {@link Scene#startMovement} on the\n * current scene. If there is no current scene, this is a no-op.\n *\n * @param {function} fn The movement function.\n * @param {function} done Function to be called when the movement finishes or is\n *     interrupted.\n */\nViewer.prototype.startMovement = function (fn, done) {\n  var scene = this._currentScene;\n  if (!scene) {\n    return;\n  }\n  scene.startMovement(fn, done);\n};\n\n/**\n * Stops the current movement.\n *\n * This method is equivalent to calling {@link Scene#stopMovement} on the\n * current scene. If there is no current scene, this is a no-op.\n */\nViewer.prototype.stopMovement = function () {\n  var scene = this._currentScene;\n  if (!scene) {\n    return;\n  }\n  scene.stopMovement();\n};\n\n/**\n * Returns the current movement.\n *\n * This method is equivalent to calling {@link Scene#movement} on the\n * current scene. If there is no current scene, this is a no-op.\n *\n * @return {function}\n */\nViewer.prototype.movement = function () {\n  var scene = this._currentScene;\n  if (!scene) {\n    return;\n  }\n  return scene.movement();\n};\n\n/**\n * Schedules an idle movement to be automatically started when the view remains\n * unchanged for the given timeout period.\n *\n * Changing the view while the idle movement is active stops the movement and\n * schedules it to start again after the same timeout period. To disable it\n * permanently, call with a null movement or an infinite timeout.\n *\n * @param {number} timeout Timeout period in milliseconds.\n * @param {function} movement Automatic movement function, or null to disable.\n */\nViewer.prototype.setIdleMovement = function (timeout, movement) {\n  this._idleTimer.setDuration(timeout);\n  this._idleMovement = movement;\n};\n\n/**\n * Stops the idle movement. It will be started again after the timeout set by\n * {@link Viewer#setIdleMovement}.\n */\nViewer.prototype.breakIdleMovement = function () {\n  this.stopMovement();\n  this._resetIdleTimer();\n};\nViewer.prototype._resetIdleTimer = function () {\n  this._idleTimer.start();\n};\nViewer.prototype._triggerIdleTimer = function () {\n  var idleMovement = this._idleMovement;\n  if (!idleMovement) {\n    return;\n  }\n  this.startMovement(idleMovement);\n};\nvar defaultSwitchDuration = 1000;\nfunction defaultTransitionUpdate(val, newScene, oldScene) {\n  var layers = newScene.listLayers();\n  layers.forEach(function (layer) {\n    layer.mergeEffects({\n      opacity: val\n    });\n  });\n  newScene._hotspotContainer.domElement().style.opacity = val;\n}\n\n/**\n * Switches to another {@link Scene scene} with a fade transition. This scene\n * becomes the current one.\n *\n * If a transition is already taking place, it is interrupted before the new one\n * starts.\n *\n * @param {Scene} newScene The scene to switch to.\n * @param {Object} opts Transition options.\n * @param {number} [opts.transitionDuration=1000] Transition duration, in\n *     milliseconds.\n * @param {number} [opts.transitionUpdate=defaultTransitionUpdate]\n *     Transition update function, with signature `f(t, newScene, oldScene)`.\n *     This function is called on each frame with `t` increasing from 0 to 1.\n *     An initial call with `t=0` and a final call with `t=1` are guaranteed.\n *     The default function sets the opacity of the new scene to `t`.\n * @param {function} done Function to call when the transition finishes or is\n *     interrupted. If the new scene is equal to the old one, no transition\n *     takes place, but this function is still called.\n */\nViewer.prototype.switchScene = function (newScene, opts, done) {\n  var self = this;\n  opts = opts || {};\n  done = done || noop;\n  var stage = this._stage;\n  var oldScene = this._currentScene;\n\n  // Do nothing if the target scene is the current one.\n  if (oldScene === newScene) {\n    done();\n    return;\n  }\n  if (this._scenes.indexOf(newScene) < 0) {\n    throw new Error('No such scene in viewer');\n  }\n\n  // Cancel an already ongoing transition. This ensures that the stage contains\n  // layers from exactly one scene before the transition begins.\n  if (this._cancelCurrentTween) {\n    this._cancelCurrentTween();\n    this._cancelCurrentTween = null;\n  }\n  var oldSceneLayers = oldScene ? oldScene.listLayers() : [];\n  var newSceneLayers = newScene.listLayers();\n  var stageLayers = stage.listLayers();\n\n  // Check that the stage contains exactly as many layers as the current scene,\n  // and that the top layer is the right one. If this test fails, either there\n  // is a bug or the user tried to modify the stage concurrently.\n  if (oldScene && (stageLayers.length !== oldSceneLayers.length || stageLayers.length > 1 && stageLayers[0] != oldSceneLayers[0])) {\n    throw new Error('Stage not in sync with viewer');\n  }\n\n  // Get the transition parameters.\n  var duration = opts.transitionDuration != null ? opts.transitionDuration : defaultSwitchDuration;\n  var update = opts.transitionUpdate != null ? opts.transitionUpdate : defaultTransitionUpdate;\n\n  // Add new scene layers into the stage before starting the transition.\n  for (var i = 0; i < newSceneLayers.length; i++) {\n    this._addLayerToStage(newSceneLayers[i]);\n  }\n\n  // Update function to be called on every frame.\n  function tweenUpdate(val) {\n    update(val, newScene, oldScene);\n  }\n\n  // Once the transition is complete, remove old scene layers from the stage and\n  // remove the event listeners. If the old scene was destroyed during the\n  // transition, this has already been taken care of. Otherwise, we still need\n  // to get a fresh copy of the scene's layers, since they might have changed\n  // during the transition.\n  function tweenDone() {\n    if (self._replacedScene) {\n      self._removeSceneEventListeners(self._replacedScene);\n      oldSceneLayers = self._replacedScene.listLayers();\n      for (var i = 0; i < oldSceneLayers.length; i++) {\n        self._removeLayerFromStage(oldSceneLayers[i]);\n      }\n      self._replacedScene = null;\n    }\n    self._cancelCurrentTween = null;\n    done();\n  }\n\n  // Store the cancelable for the transition.\n  this._cancelCurrentTween = tween(duration, tweenUpdate, tweenDone);\n\n  // Update the current and replaced scene.\n  this._currentScene = newScene;\n  this._replacedScene = oldScene;\n\n  // Emit scene and view change events.\n  this.emit('sceneChange');\n  this.emit('viewChange');\n\n  // Add event listeners to the new scene.\n  // Note that event listeners can only be removed from the old scene once the\n  // transition is complete, since layers might get added or removed in the\n  // interim.\n  this._addSceneEventListeners(newScene);\n};\nmodule.exports = Viewer;","map":{"version":3,"names":["eventEmitter","require","RenderLoop","Controls","Scene","Timer","WebGlStage","ControlCursor","HammerGestures","registerDefaultControls","registerDefaultRenderers","setOverflowHidden","setAbsolute","setFullSize","tween","noop","clearOwnProperties","Viewer","domElement","opts","_domElement","_stage","stage","appendChild","_controlContainer","document","createElement","_size","updateSize","_updateSizeListener","bind","window","addEventListener","_renderLoop","_controls","_controlMethods","controls","attach","_hammerManagerTouch","get","_hammerManagerMouse","_dragCursor","cursors","drag","start","_scenes","_currentScene","_replacedScene","_cancelCurrentTween","_layerChangeHandler","_updateSceneLayers","_viewChangeHandler","emit","_idleTimer","_resetIdleTimerHandler","_resetIdleTimer","_triggerIdleTimerHandler","_triggerIdleTimer","_stopMovementHandler","stopMovement","_idleMovement","prototype","destroy","removeEventListener","_removeSceneEventListeners","methodName","length","destroyScene","removeChild","size","width","clientWidth","height","clientHeight","setSize","renderLoop","createScene","scene","createEmptyScene","view","createLayer","source","geometry","pinFirstLevel","textureStoreOpts","layerOpts","push","i","layer","currentScene","replacedScene","oldLayers","listLayers","newLayers","concat","Math","abs","Error","indexOf","_removeLayerFromStage","_addLayerToStage","addLayer","removeLayer","unpinFirstLevel","textureStore","clearNotPinned","_addSceneEventListeners","j","layers","splice","destroyAllScenes","hasScene","listScenes","lookTo","params","done","startMovement","fn","movement","setIdleMovement","timeout","setDuration","breakIdleMovement","idleMovement","defaultSwitchDuration","defaultTransitionUpdate","val","newScene","oldScene","forEach","mergeEffects","opacity","_hotspotContainer","style","switchScene","self","oldSceneLayers","newSceneLayers","stageLayers","duration","transitionDuration","update","transitionUpdate","tweenUpdate","tweenDone","module","exports"],"sources":["E:/VR/node_modules/marzipano/src/Viewer.js"],"sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar eventEmitter = require('minimal-event-emitter');\n\nvar RenderLoop = require('./RenderLoop');\nvar Controls = require('./controls/Controls');\nvar Scene = require('./Scene');\nvar Timer = require('./Timer');\n\nvar WebGlStage = require('./stages/WebGl');\n\nvar ControlCursor = require('./controls/ControlCursor');\nvar HammerGestures = require('./controls/HammerGestures');\n\nvar registerDefaultControls = require('./controls/registerDefaultControls');\nvar registerDefaultRenderers = require('./renderers/registerDefaultRenderers');\n\nvar setOverflowHidden = require('./util/dom').setOverflowHidden;\nvar setAbsolute = require('./util/dom').setAbsolute;\nvar setFullSize = require('./util/dom').setFullSize;\n\nvar tween = require('./util/tween');\nvar noop = require('./util/noop');\nvar clearOwnProperties = require('./util/clearOwnProperties');\n\n/**\n * Signals that the current scene has changed.\n * @event Viewer#sceneChange\n */\n\n/**\n * Signals that the view of the current scene has changed. See\n * {@link View#event:change}.\n * @event Viewer#viewChange\n */\n\n/**\n * @class Viewer\n * @classdesc\n *\n * A Viewer is a container for multiple {@link Scene scenes} to be displayed\n * inside a {@link Stage stage} contained in the DOM.\n *\n * Scenes may be created by calling {@link Viewer#createScene}. Except during a\n * scene switch, a single one of them, called the current scene, is visible.\n * Calling {@link Viewer#switchScene} sets the current scene and switches to it.\n *\n * @param {Element} domElement The DOM element to contain the stage.\n * @param {Object} opts Viewer creation options.\n * @param {Object} opts.controls Options to be passed to\n *     {@link registerDefaultControls}.\n * @param {Object} opts.stage Options to be passed to the {@link Stage}\n *     constructor.\n * @param {Object} opts.cursors Cursor options.\n * @param {Object} opts.cursors.drag Drag cursor options to be passed to the\n *     {@link ControlCursor} constructor.\n */\nfunction Viewer(domElement, opts) {\n  opts = opts || {};\n\n  this._domElement = domElement;\n\n  // Add `overflow: hidden` to the domElement.\n  setOverflowHidden(domElement);\n\n  // Create stage.\n  this._stage = new WebGlStage(opts.stage);\n\n  // Register the default renderers for the selected stage.\n  registerDefaultRenderers(this._stage);\n\n  // Add the stage element into the DOM.\n  this._domElement.appendChild(this._stage.domElement());\n\n  // Create control container.\n  // Controls cannot be placed directly on the root DOM element because\n  // Hammer.js will prevent click events from reaching the elements beneath.\n\n  // The hotspot containers will be added inside the controls container.\n  this._controlContainer = document.createElement('div');\n  setAbsolute(this._controlContainer);\n  setFullSize(this._controlContainer);\n  domElement.appendChild(this._controlContainer);\n\n  // Respond to window size changes.\n  this._size = {};\n  this.updateSize();\n  this._updateSizeListener = this.updateSize.bind(this);\n  window.addEventListener('resize', this._updateSizeListener);\n\n  // Create render loop.\n  this._renderLoop = new RenderLoop(this._stage);\n\n  // Create the controls and register them with the render loop.\n  this._controls = new Controls();\n  this._controlMethods = registerDefaultControls(this._controls, this._controlContainer, opts.controls);\n  this._controls.attach(this._renderLoop);\n\n  // Expose HammerJS.\n  this._hammerManagerTouch = HammerGestures.get(this._controlContainer, 'touch');\n  this._hammerManagerMouse = HammerGestures.get(this._controlContainer, 'mouse');\n\n  // Initialize drag cursor.\n  this._dragCursor = new ControlCursor(this._controls, 'mouseViewDrag', domElement, opts.cursors && opts.cursors.drag || {});\n\n  // Start the render loop.\n  this._renderLoop.start();\n\n  // Scene list.\n  this._scenes = [];\n\n  // The currently visible scene.\n  // During a scene transition, this is the scene being switched to.\n  this._currentScene = null;\n\n  // The scene being switched from during a scene transition.\n  // This is necessary to update the layers correctly when they are added or\n  // removed during a transition.\n  this._replacedScene = null;\n\n  // The current transition.\n  this._cancelCurrentTween = null;\n\n  // The event listener fired when the current scene layers change.\n  // This is attached to the correct scene whenever the current scene changes.\n  this._layerChangeHandler = this._updateSceneLayers.bind(this);\n\n  // The event listener fired when the current scene view changes.\n  // This is attached to the correct scene whenever the current scene changes.\n  this._viewChangeHandler = this.emit.bind(this, 'viewChange');\n\n  // Setup the idle timer.\n  // By default, the timer has an infinite duration so it does nothing.\n  this._idleTimer = new Timer();\n  this._idleTimer.start();\n\n  // Reset the timer whenever the view changes.\n  this._resetIdleTimerHandler = this._resetIdleTimer.bind(this);\n  this.addEventListener('viewChange', this._resetIdleTimerHandler);\n\n  // Start the idle movement when the idle timer fires.\n  this._triggerIdleTimerHandler = this._triggerIdleTimer.bind(this);\n  this._idleTimer.addEventListener('timeout', this._triggerIdleTimerHandler);\n\n  // Stop an ongoing movement when the controls are activated or when the\n  // scene changes.\n  this._stopMovementHandler = this.stopMovement.bind(this);\n  this._controls.addEventListener('active', this._stopMovementHandler);\n  this.addEventListener('sceneChange', this._stopMovementHandler);\n\n  // The currently programmed idle movement.\n  this._idleMovement = null;\n}\n\neventEmitter(Viewer);\n\n\n/**\n * Destructor.\n */\nViewer.prototype.destroy = function() {\n\n  window.removeEventListener('resize', this._updateSizeListener);\n\n  if (this._currentScene) {\n    this._removeSceneEventListeners(this._currentScene);\n  }\n\n  if (this._replacedScene) {\n    this._removeSceneEventListeners(this._replacedScene);\n  }\n\n  this._dragCursor.destroy();\n\n  for (var methodName in this._controlMethods) {\n    this._controlMethods[methodName].destroy();\n  }\n\n  while (this._scenes.length) {\n    this.destroyScene(this._scenes[0]);\n  }\n\n  this._domElement.removeChild(this._stage.domElement());\n\n  this._stage.destroy();\n  this._renderLoop.destroy();\n  this._controls.destroy();\n  this._controls = null;\n\n  if (this._cancelCurrentTween) {\n    this._cancelCurrentTween();\n  }\n\n  clearOwnProperties(this);\n};\n\n\n/**\n * Updates the stage size to fill the containing element.\n *\n * This method is automatically called when the browser window is resized.\n * Most clients won't need to explicitly call it to keep the size up to date.\n */\nViewer.prototype.updateSize = function() {\n  var size = this._size;\n  size.width = this._domElement.clientWidth;\n  size.height = this._domElement.clientHeight;\n  this._stage.setSize(size);\n};\n\n\n/**\n * Returns the underlying {@link Stage stage}.\n * @return {Stage}\n */\nViewer.prototype.stage = function() {\n  return this._stage;\n};\n\n\n/**\n * Returns the underlying {@link RenderLoop render loop}.\n * @return {RenderLoop}\n */\nViewer.prototype.renderLoop = function() {\n  return this._renderLoop;\n};\n\n\n/**\n * Returns the underlying {@link Controls controls}.\n * @return {Controls}\n */\nViewer.prototype.controls = function() {\n  return this._controls;\n};\n\n\n/**\n * Returns the underlying DOM element.\n * @return {Element}\n */\nViewer.prototype.domElement = function() {\n  return this._domElement;\n};\n\n\n/**\n * Creates a new {@link Scene scene} with a single layer and adds it to the\n * viewer.\n *\n * The current scene does not change. To switch to the scene, call\n * {@link Viewer#switchScene}.\n *\n * @param {Object} opts Scene creation options.\n * @param {View} opts.view The scene's underlying {@link View}.\n * @param {Source} opts.source The layer's underlying {@link Source}.\n * @param {Geometry} opts.geometry The layer's underlying {@link Geometry}.\n * @param {boolean} [opts.pinFirstLevel=false] Whether to pin the first level to\n *     provide a fallback of last resort, at the cost of memory consumption.\n * @param {Object} [opts.textureStoreOpts={}] Options to pass to the\n *     {@link TextureStore} constructor.\n * @param {Object} [opts.layerOpts={}] Options to pass to the {@link Layer}\n *     constructor.\n * @return {Scene}\n */\nViewer.prototype.createScene = function(opts) {\n  opts = opts || {};\n\n  var scene = this.createEmptyScene({ view: opts.view });\n\n  scene.createLayer({\n    source: opts.source,\n    geometry: opts.geometry,\n    pinFirstLevel: opts.pinFirstLevel,\n    textureStoreOpts: opts.textureStoreOpts,\n    layerOpts: opts.layerOpts\n  });\n\n  return scene;\n};\n\n\n/**\n * Creates a new {@link Scene scene} with no layers and adds it to the viewer.\n *\n * Layers may be added to the scene by calling {@link Scene#createLayer}.\n * However, if the scene has a single layer, it is simpler to call\n * {@link Viewer#createScene} instead of this method.\n *\n * The current scene does not change. To switch to the scene, call\n * {@link Viewer#switchScene}.\n *\n * @param {Object} opts Scene creation options.\n * @param {View} opts.view The scene's underlying {@link View}.\n * @return {Scene}\n */\nViewer.prototype.createEmptyScene = function(opts) {\n  opts = opts || {};\n\n  var scene = new Scene(this, opts.view);\n  this._scenes.push(scene);\n\n  return scene;\n};\n\n\nViewer.prototype._updateSceneLayers = function() {\n  var i;\n  var layer;\n\n  var stage = this._stage;\n  var currentScene = this._currentScene;\n  var replacedScene = this._replacedScene;\n\n  var oldLayers = stage.listLayers();\n\n  // The stage contains layers from at most two scenes: the current one, on top,\n  // and the one currently being switched away from, on the bottom.\n  var newLayers = [];\n  if (replacedScene) {\n    newLayers = newLayers.concat(replacedScene.listLayers());\n  }\n  if (currentScene) {\n    newLayers = newLayers.concat(currentScene.listLayers());\n  }\n\n  // A single layer can be added or removed from the scene at a time.\n  if (Math.abs(oldLayers.length - newLayers.length) !== 1) {\n    throw new Error('Stage and scene out of sync');\n  }\n\n  if (newLayers.length < oldLayers.length) {\n    // A layer was removed.\n    for (i = 0; i < oldLayers.length; i++) {\n      layer = oldLayers[i];\n      if (newLayers.indexOf(layer) < 0) {\n        this._removeLayerFromStage(layer);\n        break;\n      }\n    }\n  }\n  if (newLayers.length > oldLayers.length) {\n    // A layer was added.\n    for (i = 0; i < newLayers.length; i++) {\n      layer = newLayers[i];\n      if (oldLayers.indexOf(layer) < 0) {\n        this._addLayerToStage(layer, i);\n      }\n    }\n  }\n\n  // TODO: When in the middle of a scene transition, call the transition update\n  // function immediately to prevent an added layer from flashing with the wrong\n  // opacity.\n};\n\n\nViewer.prototype._addLayerToStage = function(layer, i) {\n  // Pin the first level to ensure a fallback while the layer is visible.\n  // Note that this is distinct from the `pinFirstLevel` option passed to\n  // createScene(), which pins the layer even when it's not visible.\n  layer.pinFirstLevel();\n  this._stage.addLayer(layer, i);\n};\n\n\nViewer.prototype._removeLayerFromStage = function(layer) {\n  this._stage.removeLayer(layer);\n  layer.unpinFirstLevel();\n  layer.textureStore().clearNotPinned();\n};\n\n\nViewer.prototype._addSceneEventListeners = function(scene) {\n  scene.addEventListener('layerChange', this._layerChangeHandler);\n  scene.addEventListener('viewChange', this._viewChangeHandler);\n};\n\n\nViewer.prototype._removeSceneEventListeners = function(scene) {\n  scene.removeEventListener('layerChange', this._layerChangeHandler);\n  scene.removeEventListener('viewChange', this._viewChangeHandler);\n};\n\n\n/**\n * Destroys a {@link Scene scene} and removes it from the viewer.\n * @param {Scene} scene\n */\nViewer.prototype.destroyScene = function(scene) {\n  var i = this._scenes.indexOf(scene);\n  if (i < 0) {\n    throw new Error('No such scene in viewer');\n  }\n\n  var j;\n  var layers;\n\n  if (this._currentScene === scene) {\n    // The destroyed scene is the current scene.\n    // Remove event listeners, remove layers from stage and cancel transition.\n    this._removeSceneEventListeners(scene);\n    layers = scene.listLayers();\n    for (j = 0; j < layers.length; j++) {\n      this._removeLayerFromStage(layers[j]);\n    }\n    if (this._cancelCurrentTween) {\n      this._cancelCurrentTween();\n      this._cancelCurrentTween = null;\n    }\n    this._currentScene = null;\n    this.emit('sceneChange');\n  }\n\n  if (this._replacedScene === scene) {\n    // The destroyed scene is being switched away from.\n    // Remove event listeners and remove layers from stage.\n    this._removeSceneEventListeners(scene);\n    layers = scene.listLayers();\n    for (j = 0; j < layers.length; j++) {\n      this._removeLayerFromStage(layers[j]);\n    }\n    this._replacedScene = null;\n  }\n\n  this._scenes.splice(i, 1);\n\n  scene.destroy();\n};\n\n\n/**\n * Destroys all {@link Scene scenes} and removes them from the viewer.\n */\nViewer.prototype.destroyAllScenes = function() {\n  while (this._scenes.length > 0) {\n    this.destroyScene(this._scenes[0]);\n  }\n};\n\n\n/**\n * Returns whether the viewer contains a {@link Scene scene}.\n * @param {Scene} scene\n * @return {boolean}\n */\nViewer.prototype.hasScene = function(scene) {\n  return this._scenes.indexOf(scene) >= 0;\n};\n\n\n/**\n * Returns a list of all {@link Scene scenes}.\n * @return {Scene[]}\n */\nViewer.prototype.listScenes = function() {\n  return [].concat(this._scenes);\n};\n\n\n/**\n * Returns the current {@link Scene scene}, or null if there isn't one.\n *\n * To change the current scene, call {@link Viewer#switchScene}.\n *\n * @return {Scene}\n */\nViewer.prototype.scene = function() {\n  return this._currentScene;\n};\n\n\n/**\n * Returns the {@link View view} for the current {@link Scene scene}, or null\n * if there isn't one.\n * @return {View}\n */\nViewer.prototype.view = function() {\n  var scene = this._currentScene;\n  if (scene) {\n    return scene.view();\n  }\n  return null;\n};\n\n\n/**\n * Tweens the {@link View view} for the current {@link Scene scene}.\n *\n * This method is equivalent to calling {@link Scene#lookTo} on the current\n * scene.\n *\n * @param {Object} opts Options to pass into {@link Scene#lookTo}.\n * @param {function} done Function to call when the tween is complete.\n */\nViewer.prototype.lookTo = function(params, opts, done) {\n  // TODO: is it an error to call lookTo when no scene is displayed?\n  var scene = this._currentScene;\n  if (scene) {\n    scene.lookTo(params, opts, done);\n  }\n};\n\n\n/**\n * Starts a movement, possibly replacing the current movement.\n *\n * This method is equivalent to calling {@link Scene#startMovement} on the\n * current scene. If there is no current scene, this is a no-op.\n *\n * @param {function} fn The movement function.\n * @param {function} done Function to be called when the movement finishes or is\n *     interrupted.\n */\nViewer.prototype.startMovement = function(fn, done) {\n  var scene = this._currentScene;\n  if (!scene) {\n    return;\n  }\n  scene.startMovement(fn, done);\n};\n\n\n/**\n * Stops the current movement.\n *\n * This method is equivalent to calling {@link Scene#stopMovement} on the\n * current scene. If there is no current scene, this is a no-op.\n */\nViewer.prototype.stopMovement = function() {\n  var scene = this._currentScene;\n  if (!scene) {\n    return;\n  }\n  scene.stopMovement();\n};\n\n\n/**\n * Returns the current movement.\n *\n * This method is equivalent to calling {@link Scene#movement} on the\n * current scene. If there is no current scene, this is a no-op.\n *\n * @return {function}\n */\nViewer.prototype.movement = function() {\n  var scene = this._currentScene;\n  if (!scene) {\n    return;\n  }\n  return scene.movement();\n};\n\n\n/**\n * Schedules an idle movement to be automatically started when the view remains\n * unchanged for the given timeout period.\n *\n * Changing the view while the idle movement is active stops the movement and\n * schedules it to start again after the same timeout period. To disable it\n * permanently, call with a null movement or an infinite timeout.\n *\n * @param {number} timeout Timeout period in milliseconds.\n * @param {function} movement Automatic movement function, or null to disable.\n */\nViewer.prototype.setIdleMovement = function(timeout, movement) {\n  this._idleTimer.setDuration(timeout);\n  this._idleMovement = movement;\n};\n\n\n/**\n * Stops the idle movement. It will be started again after the timeout set by\n * {@link Viewer#setIdleMovement}.\n */\nViewer.prototype.breakIdleMovement = function() {\n  this.stopMovement();\n  this._resetIdleTimer();\n};\n\n\nViewer.prototype._resetIdleTimer = function() {\n  this._idleTimer.start();\n};\n\n\nViewer.prototype._triggerIdleTimer = function() {\n  var idleMovement = this._idleMovement;\n  if (!idleMovement) {\n    return;\n  }\n  this.startMovement(idleMovement);\n};\n\n\nvar defaultSwitchDuration = 1000;\n\nfunction defaultTransitionUpdate(val, newScene, oldScene) {\n  var layers = newScene.listLayers();\n  layers.forEach(function(layer) {\n    layer.mergeEffects({ opacity: val });\n  });\n\n  newScene._hotspotContainer.domElement().style.opacity = val;\n}\n\n\n/**\n * Switches to another {@link Scene scene} with a fade transition. This scene\n * becomes the current one.\n *\n * If a transition is already taking place, it is interrupted before the new one\n * starts.\n *\n * @param {Scene} newScene The scene to switch to.\n * @param {Object} opts Transition options.\n * @param {number} [opts.transitionDuration=1000] Transition duration, in\n *     milliseconds.\n * @param {number} [opts.transitionUpdate=defaultTransitionUpdate]\n *     Transition update function, with signature `f(t, newScene, oldScene)`.\n *     This function is called on each frame with `t` increasing from 0 to 1.\n *     An initial call with `t=0` and a final call with `t=1` are guaranteed.\n *     The default function sets the opacity of the new scene to `t`.\n * @param {function} done Function to call when the transition finishes or is\n *     interrupted. If the new scene is equal to the old one, no transition\n *     takes place, but this function is still called.\n */\nViewer.prototype.switchScene = function(newScene, opts, done) {\n  var self = this;\n\n  opts = opts || {};\n  done = done || noop;\n\n  var stage = this._stage;\n\n  var oldScene = this._currentScene;\n\n  // Do nothing if the target scene is the current one.\n  if (oldScene === newScene) {\n    done();\n    return;\n  }\n\n  if (this._scenes.indexOf(newScene) < 0) {\n    throw new Error('No such scene in viewer');\n  }\n\n  // Cancel an already ongoing transition. This ensures that the stage contains\n  // layers from exactly one scene before the transition begins.\n  if (this._cancelCurrentTween) {\n    this._cancelCurrentTween();\n    this._cancelCurrentTween = null;\n  }\n\n  var oldSceneLayers = oldScene ? oldScene.listLayers() : [];\n  var newSceneLayers = newScene.listLayers();\n  var stageLayers = stage.listLayers();\n\n  // Check that the stage contains exactly as many layers as the current scene,\n  // and that the top layer is the right one. If this test fails, either there\n  // is a bug or the user tried to modify the stage concurrently.\n  if (oldScene && ((stageLayers.length !== oldSceneLayers.length) ||\n      (stageLayers.length > 1 && stageLayers[0] != oldSceneLayers[0]))) {\n    throw new Error('Stage not in sync with viewer');\n  }\n\n  // Get the transition parameters.\n  var duration = opts.transitionDuration != null ?\n      opts.transitionDuration : defaultSwitchDuration;\n  var update = opts.transitionUpdate != null ?\n      opts.transitionUpdate : defaultTransitionUpdate;\n\n  // Add new scene layers into the stage before starting the transition.\n  for (var i = 0; i < newSceneLayers.length; i++) {\n    this._addLayerToStage(newSceneLayers[i]);\n  }\n\n  // Update function to be called on every frame.\n  function tweenUpdate(val) {\n    update(val, newScene, oldScene);\n  }\n\n  // Once the transition is complete, remove old scene layers from the stage and\n  // remove the event listeners. If the old scene was destroyed during the\n  // transition, this has already been taken care of. Otherwise, we still need\n  // to get a fresh copy of the scene's layers, since they might have changed\n  // during the transition.\n  function tweenDone() {\n    if (self._replacedScene) {\n      self._removeSceneEventListeners(self._replacedScene);\n      oldSceneLayers = self._replacedScene.listLayers();\n      for (var i = 0; i < oldSceneLayers.length; i++) {\n        self._removeLayerFromStage(oldSceneLayers[i]);\n      }\n      self._replacedScene = null;\n    }\n    self._cancelCurrentTween = null;\n    done();\n  }\n\n  // Store the cancelable for the transition.\n  this._cancelCurrentTween = tween(duration, tweenUpdate, tweenDone);\n\n  // Update the current and replaced scene.\n  this._currentScene = newScene;\n  this._replacedScene = oldScene;\n\n  // Emit scene and view change events.\n  this.emit('sceneChange');\n  this.emit('viewChange');\n\n  // Add event listeners to the new scene.\n  // Note that event listeners can only be removed from the old scene once the\n  // transition is complete, since layers might get added or removed in the\n  // interim.\n  this._addSceneEventListeners(newScene);\n};\n\n\nmodule.exports = Viewer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}