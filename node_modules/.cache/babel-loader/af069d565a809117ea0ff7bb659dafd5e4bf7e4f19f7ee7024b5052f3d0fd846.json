{"ast":null,"code":"/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar mod = require('../util/mod');\nvar defaultCapacity = 64;\n\n// A map data structure for keys implementing hash() and equals() and arbitrary\n// values. The capacity, if given, is just a hint; the map is allowed to exceed\n// it, but performance may suffer.\nfunction Map(capacity) {\n  if (capacity != null && (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {\n    throw new Error('Map: invalid capacity');\n  }\n  this._capacity = capacity || defaultCapacity;\n  this._keyBuckets = [];\n  this._valBuckets = [];\n  for (var i = 0; i < this._capacity; i++) {\n    this._keyBuckets.push([]);\n    this._valBuckets.push([]);\n  }\n  this._size = 0;\n}\n\n// Returns the value associated with the specified key, or null if not found.\nMap.prototype.get = function (key) {\n  var h = mod(key.hash(), this._capacity);\n  var keyBucket = this._keyBuckets[h];\n  for (var i = 0; i < keyBucket.length; i++) {\n    var existingKey = keyBucket[i];\n    if (key.equals(existingKey)) {\n      var valBucket = this._valBuckets[h];\n      var existingValue = valBucket[i];\n      return existingValue;\n    }\n  }\n  return null;\n};\n\n// Associates the specified value with the specified key, possibly replacing the\n// currently associated value.\n// Returns the replaced value, or null if no value was replaced.\nMap.prototype.set = function (key, val) {\n  var h = mod(key.hash(), this._capacity);\n  var keyBucket = this._keyBuckets[h];\n  var valBucket = this._valBuckets[h];\n  for (var i = 0; i < keyBucket.length; i++) {\n    var existingKey = keyBucket[i];\n    if (key.equals(existingKey)) {\n      var existingValue = valBucket[i];\n      keyBucket[i] = key;\n      valBucket[i] = val;\n      return existingValue;\n    }\n  }\n  keyBucket.push(key);\n  valBucket.push(val);\n  this._size++;\n  return null;\n};\n\n// Removes the key-value pair associated with the specified key.\n// Returns the removed value, or null if not found.\nMap.prototype.del = function (key) {\n  var h = mod(key.hash(), this._capacity);\n  var keyBucket = this._keyBuckets[h];\n  var valBucket = this._valBuckets[h];\n  for (var i = 0; i < keyBucket.length; i++) {\n    var existingKey = keyBucket[i];\n    if (key.equals(existingKey)) {\n      var existingValue = valBucket[i];\n      // Splice manually to avoid Array#splice return value allocation.\n      for (var j = i; j < keyBucket.length - 1; j++) {\n        keyBucket[j] = keyBucket[j + 1];\n        valBucket[j] = valBucket[j + 1];\n      }\n      keyBucket.length = keyBucket.length - 1;\n      valBucket.length = valBucket.length - 1;\n      this._size--;\n      return existingValue;\n    }\n  }\n  return null;\n};\n\n// Returns whether there is a value associated with the specified key.\nMap.prototype.has = function (key) {\n  var h = mod(key.hash(), this._capacity);\n  var keyBucket = this._keyBuckets[h];\n  for (var i = 0; i < keyBucket.length; i++) {\n    var existingKey = keyBucket[i];\n    if (key.equals(existingKey)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Returns the number of key-value pairs in the map.\nMap.prototype.size = function () {\n  return this._size;\n};\n\n// Removes all key-value pairs from the map.\nMap.prototype.clear = function () {\n  for (var i = 0; i < this._capacity; i++) {\n    this._keyBuckets[i].length = 0;\n    this._valBuckets[i].length = 0;\n  }\n  this._size = 0;\n};\n\n// Calls fn(key, value) for each key-value pair in the map, in an unspecified\n// order. Returns the number of times fn was called.\n// The result is unspecified if the map is mutated during iteration.\nMap.prototype.forEach = function (fn) {\n  var count = 0;\n  for (var i = 0; i < this._capacity; i++) {\n    var keyBucket = this._keyBuckets[i];\n    var valBucket = this._valBuckets[i];\n    for (var j = 0; j < keyBucket.length; j++) {\n      fn(keyBucket[j], valBucket[j]);\n      count += 1;\n    }\n  }\n  return count;\n};\nmodule.exports = Map;","map":{"version":3,"names":["mod","require","defaultCapacity","Map","capacity","isFinite","Math","floor","Error","_capacity","_keyBuckets","_valBuckets","i","push","_size","prototype","get","key","h","hash","keyBucket","length","existingKey","equals","valBucket","existingValue","set","val","del","j","has","size","clear","forEach","fn","count","module","exports"],"sources":["E:/VR/node_modules/marzipano/src/collections/Map.js"],"sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar mod = require('../util/mod');\n\nvar defaultCapacity = 64;\n\n// A map data structure for keys implementing hash() and equals() and arbitrary\n// values. The capacity, if given, is just a hint; the map is allowed to exceed\n// it, but performance may suffer.\nfunction Map(capacity) {\n  if (capacity != null &&\n      (!isFinite(capacity) || Math.floor(capacity) !== capacity || capacity < 1)) {\n    throw new Error('Map: invalid capacity');\n  }\n  this._capacity = capacity || defaultCapacity;\n\n  this._keyBuckets = [];\n  this._valBuckets = [];\n  for (var i = 0; i < this._capacity; i++) {\n    this._keyBuckets.push([]);\n    this._valBuckets.push([]);\n  }\n  this._size = 0;\n}\n\n// Returns the value associated with the specified key, or null if not found.\nMap.prototype.get = function(key) {\n  var h = mod(key.hash(), this._capacity);\n  var keyBucket = this._keyBuckets[h];\n  for (var i = 0; i < keyBucket.length; i++) {\n    var existingKey = keyBucket[i];\n    if (key.equals(existingKey)) {\n      var valBucket = this._valBuckets[h];\n      var existingValue = valBucket[i];\n      return existingValue;\n    }\n  }\n  return null;\n};\n\n// Associates the specified value with the specified key, possibly replacing the\n// currently associated value.\n// Returns the replaced value, or null if no value was replaced.\nMap.prototype.set = function(key, val) {\n  var h = mod(key.hash(), this._capacity);\n  var keyBucket = this._keyBuckets[h];\n  var valBucket = this._valBuckets[h];\n  for (var i = 0; i < keyBucket.length; i++) {\n    var existingKey = keyBucket[i];\n    if (key.equals(existingKey)) {\n      var existingValue = valBucket[i];\n      keyBucket[i] = key;\n      valBucket[i] = val;\n      return existingValue;\n    }\n  }\n  keyBucket.push(key);\n  valBucket.push(val);\n  this._size++;\n  return null;\n};\n\n// Removes the key-value pair associated with the specified key.\n// Returns the removed value, or null if not found.\nMap.prototype.del = function(key) {\n  var h = mod(key.hash(), this._capacity);\n  var keyBucket = this._keyBuckets[h];\n  var valBucket = this._valBuckets[h];\n  for (var i = 0; i < keyBucket.length; i++) {\n    var existingKey = keyBucket[i];\n    if (key.equals(existingKey)) {\n      var existingValue = valBucket[i];\n      // Splice manually to avoid Array#splice return value allocation.\n      for (var j = i; j < keyBucket.length - 1; j++) {\n        keyBucket[j] = keyBucket[j+1];\n        valBucket[j] = valBucket[j+1];\n      }\n      keyBucket.length = keyBucket.length - 1;\n      valBucket.length = valBucket.length - 1;\n      this._size--;\n      return existingValue;\n    }\n  }\n  return null;\n};\n\n// Returns whether there is a value associated with the specified key.\nMap.prototype.has = function(key) {\n  var h = mod(key.hash(), this._capacity);\n  var keyBucket = this._keyBuckets[h];\n  for (var i = 0; i < keyBucket.length; i++) {\n    var existingKey = keyBucket[i];\n    if (key.equals(existingKey)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Returns the number of key-value pairs in the map.\nMap.prototype.size = function() {\n  return this._size;\n};\n\n// Removes all key-value pairs from the map.\nMap.prototype.clear = function() {\n  for (var i = 0; i < this._capacity; i++) {\n    this._keyBuckets[i].length = 0;\n    this._valBuckets[i].length = 0;\n  }\n  this._size = 0;\n};\n\n// Calls fn(key, value) for each key-value pair in the map, in an unspecified\n// order. Returns the number of times fn was called.\n// The result is unspecified if the map is mutated during iteration.\nMap.prototype.forEach = function(fn) {\n  var count = 0;\n  for (var i = 0; i < this._capacity; i++) {\n    var keyBucket = this._keyBuckets[i];\n    var valBucket = this._valBuckets[i];\n    for (var j = 0; j < keyBucket.length; j++) {\n      fn(keyBucket[j], valBucket[j]);\n      count += 1;\n    }\n  }\n  return count;\n};\n\nmodule.exports = Map;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}