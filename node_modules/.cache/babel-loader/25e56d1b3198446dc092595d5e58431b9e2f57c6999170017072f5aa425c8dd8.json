{"ast":null,"code":"/*! Hammer.JS - v2.0.4 - 2014-09-28\r\n * http://hammerjs.github.io/\r\n *\r\n * Copyright (c) 2014 Jorik Tangelder;\r\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n\n  /**\r\n   * set a timeout with a given scope\r\n   * @param {Function} fn\r\n   * @param {Number} timeout\r\n   * @param {Object} context\r\n   * @returns {number}\r\n   */\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n\n  /**\r\n   * if the argument is an array, we want to execute the fn on each entry\r\n   * if it aint an array we don't want to do a thing.\r\n   * this is used by all the methods that accept a single and array argument.\r\n   * @param {*|Array} arg\r\n   * @param {String} fn\r\n   * @param {Object} [context]\r\n   * @returns {Boolean}\r\n   */\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * walk objects and arrays\r\n   * @param {Object} obj\r\n   * @param {Function} iterator\r\n   * @param {Object} context\r\n   */\n  function each(obj, iterator, context) {\n    var i;\n    if (!obj) {\n      return;\n    }\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n\n  /**\r\n   * extend object.\r\n   * means that properties in dest will be overwritten by the ones in src.\r\n   * @param {Object} dest\r\n   * @param {Object} src\r\n   * @param {Boolean} [merge]\r\n   * @returns {Object} dest\r\n   */\n  function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n      i++;\n    }\n    return dest;\n  }\n\n  /**\r\n   * merge the values from src in the dest.\r\n   * means that properties that exist in dest will not be overwritten by src\r\n   * @param {Object} dest\r\n   * @param {Object} src\r\n   * @returns {Object} dest\r\n   */\n  function merge(dest, src) {\n    return extend(dest, src, true);\n  }\n\n  /**\r\n   * simple class inheritance\r\n   * @param {Function} child\r\n   * @param {Function} base\r\n   * @param {Object} [properties]\r\n   */\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n      childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n    if (properties) {\n      extend(childP, properties);\n    }\n  }\n\n  /**\r\n   * simple function bind\r\n   * @param {Function} fn\r\n   * @param {Object} context\r\n   * @returns {Function}\r\n   */\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n\n  /**\r\n   * let a boolean value also be a function that must return a boolean\r\n   * this first item in args will be used as the context\r\n   * @param {Boolean|Function} val\r\n   * @param {Array} [args]\r\n   * @returns {Boolean}\r\n   */\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n  }\n\n  /**\r\n   * use the val2 when val1 is undefined\r\n   * @param {*} val1\r\n   * @param {*} val2\r\n   * @returns {*}\r\n   */\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n\n  /**\r\n   * addEventListener with multiple events at once\r\n   * @param {EventTarget} target\r\n   * @param {String} types\r\n   * @param {Function} handler\r\n   */\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n\n  /**\r\n   * removeEventListener with multiple events at once\r\n   * @param {EventTarget} target\r\n   * @param {String} types\r\n   * @param {Function} handler\r\n   */\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n\n  /**\r\n   * find if a node is in the given parent\r\n   * @method hasParent\r\n   * @param {HTMLElement} node\r\n   * @param {HTMLElement} parent\r\n   * @return {Boolean} found\r\n   */\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  }\n\n  /**\r\n   * small indexOf wrapper\r\n   * @param {String} str\r\n   * @param {String} find\r\n   * @returns {Boolean} found\r\n   */\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n\n  /**\r\n   * split string on whitespace\r\n   * @param {String} str\r\n   * @returns {Array} words\r\n   */\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n\n  /**\r\n   * find if a array contains the object using indexOf or a simple polyFill\r\n   * @param {Array} src\r\n   * @param {String} find\r\n   * @param {String} [findByKey]\r\n   * @return {Boolean|Number} false when not found, or the index\r\n   */\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n        i++;\n      }\n      return -1;\n    }\n  }\n\n  /**\r\n   * convert array-like objects to real arrays\r\n   * @param {Object} obj\r\n   * @returns {Array}\r\n   */\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n\n  /**\r\n   * unique array with objects based on a key (like 'id') or just by the array's value\r\n   * @param {Array} src [{id:1},{id:2},{id:1}]\r\n   * @param {String} [key]\r\n   * @param {Boolean} [sort=False]\r\n   * @returns {Array} [{id:1},{id:2}]\r\n   */\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n      values[i] = val;\n      i++;\n    }\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n    return results;\n  }\n\n  /**\r\n   * get the prefixed property\r\n   * @param {Object} obj\r\n   * @param {String} property\r\n   * @returns {String|Undefined} prefixed\r\n   */\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n      if (prop in obj) {\n        return prop;\n      }\n      i++;\n    }\n    return undefined;\n  }\n\n  /**\r\n   * get a unique id\r\n   * @returns {number} uniqueId\r\n   */\n  var _uniqueId = 1;\n  function uniqueId() {\n    return _uniqueId++;\n  }\n\n  /**\r\n   * get the window object of an element\r\n   * @param {HTMLElement} element\r\n   * @returns {DocumentView|Window}\r\n   */\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument;\n    return doc.defaultView || doc.parentWindow;\n  }\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = ('ontouchstart' in window);\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n  /**\r\n   * create new input type manager\r\n   * @param {Manager} manager\r\n   * @param {Function} callback\r\n   * @returns {Input}\r\n   * @constructor\r\n   */\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n    this.init();\n  }\n  Input.prototype = {\n    /**\r\n     * should handle the inputEvent data and trigger the callback\r\n     * @virtual\r\n     */\n    handler: function () {},\n    /**\r\n     * bind the events\r\n     */\n    init: function () {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n    /**\r\n     * unbind the events\r\n     */\n    destroy: function () {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n\n  /**\r\n   * create new input type manager\r\n   * called by the Manager constructor\r\n   * @param {Hammer} manager\r\n   * @returns {Input}\r\n   */\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n    return new Type(manager, inputHandler);\n  }\n\n  /**\r\n   * handle input events\r\n   * @param {Manager} manager\r\n   * @param {String} eventType\r\n   * @param {Object} input\r\n   */\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n    if (isFirst) {\n      manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n\n  /**\r\n   * extend the data with some usable properties like scale, rotate, velocity etc\r\n   * @param {Object} manager\r\n   * @param {Object} input\r\n   */\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n    input.target = target;\n  }\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n\n  /**\r\n   * velocity is calculated every x ms\r\n   * @param {Object} session\r\n   * @param {Object} input\r\n   */\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n      deltaTime = input.timeStamp - last.timeStamp,\n      velocity,\n      velocityX,\n      velocityY,\n      direction;\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = last.deltaX - input.deltaX;\n      var deltaY = last.deltaY - input.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n\n  /**\r\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n   * @param {Object} input\r\n   * @returns {Object} clonedInputData\r\n   */\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n\n  /**\r\n   * get the center of all the pointers\r\n   * @param {Array} pointers\r\n   * @return {Object} center contains `x` and `y` properties\r\n   */\n  function getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n    var x = 0,\n      y = 0,\n      i = 0;\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n\n  /**\r\n   * calculate the velocity between two points. unit is in px per ms.\r\n   * @param {Number} deltaTime\r\n   * @param {Number} x\r\n   * @param {Number} y\r\n   * @return {Object} velocity `x` and `y`\r\n   */\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n\n  /**\r\n   * get the direction between two points\r\n   * @param {Number} x\r\n   * @param {Number} y\r\n   * @return {Number} direction\r\n   */\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n    if (abs(x) >= abs(y)) {\n      return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n\n  /**\r\n   * calculate the absolute distance between two points\r\n   * @param {Object} p1 {x, y}\r\n   * @param {Object} p2 {x, y}\r\n   * @param {Array} [props] containing x and y keys\r\n   * @return {Number} distance\r\n   */\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n\n  /**\r\n   * calculate the angle between two coordinates\r\n   * @param {Object} p1\r\n   * @param {Object} p2\r\n   * @param {Array} [props] containing x and y keys\r\n   * @return {Number} angle\r\n   */\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n      y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n\n  /**\r\n   * calculate the rotation degrees between two pointersets\r\n   * @param {Array} start array of pointers\r\n   * @param {Array} end array of pointers\r\n   * @return {Number} rotation\r\n   */\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n\n  /**\r\n   * calculate the scale factor between two pointersets\r\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n   * @param {Array} start array of pointers\r\n   * @param {Array} end array of pointers\r\n   * @return {Number} scale\r\n   */\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n  /**\r\n   * Mouse events input\r\n   * @constructor\r\n   * @extends Input\r\n   */\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n  inherit(MouseInput, Input, {\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type];\n\n      // on start we want to have the left mouse button down\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      }\n\n      // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n      if (!this.pressed || !this.allow) {\n        return;\n      }\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  };\n\n  // in IE10 the pointer types is defined as an enum\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n  };\n\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n  // IE10 has prefixed support, and case-sensitive\n  if (window.MSPointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n\n  /**\r\n   * Pointer events input\r\n   * @constructor\r\n   * @extends Input\r\n   */\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n  inherit(PointerEventInput, Input, {\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH;\n\n      // get index of the event in the store\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n      // start and mouse must be down\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      }\n\n      // it not found, so the pointer hasn't been down (so it's probably a hover)\n      if (storeIndex < 0) {\n        return;\n      }\n\n      // update the event in the store\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\r\n   * Touch events input\r\n   * @constructor\r\n   * @extends Input\r\n   */\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n      // should we handle the touch events?\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n      if (!this.started) {\n        return;\n      }\n      var touches = normalizeSingleTouches.call(this, ev, type);\n\n      // when done, reset the started state\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\r\n   * @this {TouchInput}\r\n   * @param {Object} ev\r\n   * @param {Number} type flag\r\n   * @returns {undefined|Array} [all, changed]\r\n   */\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n    return [all, changed];\n  }\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n  /**\r\n   * Multi-user touch events input\r\n   * @constructor\r\n   * @extends Input\r\n   */\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n      if (!touches) {\n        return;\n      }\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n\n  /**\r\n   * @this {TouchInput}\r\n   * @param {Object} ev\r\n   * @param {Number} type flag\r\n   * @returns {undefined|Array} [all, changed]\r\n   */\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n    var i,\n      targetTouches,\n      changedTouches = toArray(ev.changedTouches),\n      changedTargetTouches = [],\n      target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n      i = 0;\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      }\n\n      // cleanup removed touches\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n      i++;\n    }\n    if (!changedTargetTouches.length) {\n      return;\n    }\n    return [\n    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n\n  /**\r\n   * Combined touch and mouse input\r\n   *\r\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n   * This because touch devices also emit mouse events while doing a touch.\r\n   *\r\n   * @constructor\r\n   * @extends Input\r\n   */\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n  }\n  inherit(TouchMouseInput, Input, {\n    /**\r\n     * handle mouse and touch events\r\n     * @param {Hammer} manager\r\n     * @param {String} inputEvent\r\n     * @param {Object} inputData\r\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n        isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n      // when we're in a touch event, so  block all upcoming mouse events\n      // most mobile browser also emit mouseevents, right after touchstart\n      if (isTouch) {\n        this.mouse.allow = false;\n      } else if (isMouse && !this.mouse.allow) {\n        return;\n      }\n\n      // reset the allowMouse when we're done\n      if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n        this.mouse.allow = true;\n      }\n      this.callback(manager, inputEvent, inputData);\n    },\n    /**\r\n     * remove the event listeners\r\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n  // magical touchAction value\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n\n  /**\r\n   * Touch Action\r\n   * sets the touchAction property or uses the js alternative\r\n   * @param {Manager} manager\r\n   * @param {String} value\r\n   * @constructor\r\n   */\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  TouchAction.prototype = {\n    /**\r\n     * set the touchAction value on the element or enable the polyfill\r\n     * @param {String} value\r\n     */\n    set: function (value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n      if (NATIVE_TOUCH_ACTION) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n      this.actions = value.toLowerCase().trim();\n    },\n    /**\r\n     * just re-set the touchAction value\r\n     */\n    update: function () {\n      this.set(this.manager.options.touchAction);\n    },\n    /**\r\n     * compute the value for the touchAction property based on the recognizer's settings\r\n     * @returns {String} value\r\n     */\n    compute: function () {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n    /**\r\n     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n     * @param {Object} input\r\n     */\n    preventDefaults: function (input) {\n      // not needed with native support for the touchAction property\n      if (NATIVE_TOUCH_ACTION) {\n        return;\n      }\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection;\n\n      // if the touch action did prevented once this session\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n    /**\r\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n     * @param {Object} srcEvent\r\n     */\n    preventSrc: function (srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n\n  /**\r\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n   * @param {String} actions\r\n   * @returns {*}\r\n   */\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // pan-x and pan-y can be combined\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n    return TOUCH_ACTION_AUTO;\n  }\n\n  /**\r\n   * Recognizer flow explained; *\r\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n   *\r\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n   * which determines with state it should be.\r\n   *\r\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n   * POSSIBLE to give it another change on the next cycle.\r\n   *\r\n   *               Possible\r\n   *                  |\r\n   *            +-----+---------------+\r\n   *            |                     |\r\n   *      +-----+-----+               |\r\n   *      |           |               |\r\n   *   Failed      Cancelled          |\r\n   *                          +-------+------+\r\n   *                          |              |\r\n   *                      Recognized       Began\r\n   *                                         |\r\n   *                                      Changed\r\n   *                                         |\r\n   *                                  Ended/Recognized\r\n   */\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n\n  /**\r\n   * Recognizer\r\n   * Every recognizer needs to extend from this class.\r\n   * @constructor\r\n   * @param {Object} options\r\n   */\n  function Recognizer(options) {\n    this.id = uniqueId();\n    this.manager = null;\n    this.options = merge(options || {}, this.defaults);\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  Recognizer.prototype = {\n    /**\r\n     * @virtual\r\n     * @type {Object}\r\n     */\n    defaults: {},\n    /**\r\n     * set options\r\n     * @param {Object} options\r\n     * @return {Recognizer}\r\n     */\n    set: function (options) {\n      extend(this.options, options);\n\n      // also update the touchAction, in case something changed about the directions/enabled state\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n    /**\r\n     * recognize simultaneous with an other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\n    recognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n      return this;\n    },\n    /**\r\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\n    dropRecognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n    /**\r\n     * recognizer can only run when an other is failing\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\n    requireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n      return this;\n    },\n    /**\r\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\n    dropRequireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n      return this;\n    },\n    /**\r\n     * has require failures boolean\r\n     * @returns {boolean}\r\n     */\n    hasRequireFailures: function () {\n      return this.requireFail.length > 0;\n    },\n    /**\r\n     * if the recognizer can recognize simultaneous with an other recognizer\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Boolean}\r\n     */\n    canRecognizeWith: function (otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n    /**\r\n     * You should use `tryEmit` instead of `emit` directly to check\r\n     * that all the needed recognizers has failed before emitting.\r\n     * @param {Object} input\r\n     */\n    emit: function (input) {\n      var self = this;\n      var state = this.state;\n      function emit(withState) {\n        self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n      }\n\n      // 'panstart' and 'panmove'\n      if (state < STATE_ENDED) {\n        emit(true);\n      }\n      emit(); // simple 'eventName' events\n\n      // panend and pancancel\n      if (state >= STATE_ENDED) {\n        emit(true);\n      }\n    },\n    /**\r\n     * Check that all the require failure recognizers has failed,\r\n     * if true, it emits a gesture event,\r\n     * otherwise, setup the state to FAILED.\r\n     * @param {Object} input\r\n     */\n    tryEmit: function (input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      }\n      // it's failing anyway\n      this.state = STATE_FAILED;\n    },\n    /**\r\n     * can we emit?\r\n     * @returns {boolean}\r\n     */\n    canEmit: function () {\n      var i = 0;\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n        i++;\n      }\n      return true;\n    },\n    /**\r\n     * update the recognizer\r\n     * @param {Object} inputData\r\n     */\n    recognize: function (inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = extend({}, inputData);\n\n      // is is enabled and allow recognizing?\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      }\n\n      // reset when we've reached the end\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n      this.state = this.process(inputDataClone);\n\n      // the recognizer has recognized a gesture\n      // so trigger an event\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n    /**\r\n     * return the state of the recognizer\r\n     * the actual recognizing happens in this method\r\n     * @virtual\r\n     * @param {Object} inputData\r\n     * @returns {Const} STATE\r\n     */\n    process: function (inputData) {},\n    // jshint ignore:line\n\n    /**\r\n     * return the preferred touch-action\r\n     * @virtual\r\n     * @returns {Array}\r\n     */\n    getTouchAction: function () {},\n    /**\r\n     * called when the gesture isn't allowed to recognize\r\n     * like when another is being recognized or it is disabled\r\n     * @virtual\r\n     */\n    reset: function () {}\n  };\n\n  /**\r\n   * get a usable string, used as event postfix\r\n   * @param {Const} state\r\n   * @returns {String} state\r\n   */\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n    return '';\n  }\n\n  /**\r\n   * direction cons to string\r\n   * @param {Const} direction\r\n   * @returns {String}\r\n   */\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n    return '';\n  }\n\n  /**\r\n   * get a recognizer by name if it is bound to a manager\r\n   * @param {Recognizer|String} otherRecognizer\r\n   * @param {Recognizer} recognizer\r\n   * @returns {Recognizer}\r\n   */\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n  }\n\n  /**\r\n   * This recognizer is just used as a base for the simple attribute recognizers.\r\n   * @constructor\r\n   * @extends Recognizer\r\n   */\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n  inherit(AttrRecognizer, Recognizer, {\n    /**\r\n     * @namespace\r\n     * @memberof AttrRecognizer\r\n     */\n    defaults: {\n      /**\r\n       * @type {Number}\r\n       * @default 1\r\n       */\n      pointers: 1\n    },\n    /**\r\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {Boolean} recognized\r\n     */\n    attrTest: function (input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n    /**\r\n     * Process the input and return the state for the recognizer\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {*} State\r\n     */\n    process: function (input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input);\n\n      // on cancel input and we've recognized before, return STATE_CANCELLED\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n        return state | STATE_CHANGED;\n      }\n      return STATE_FAILED;\n    }\n  });\n\n  /**\r\n   * Pan\r\n   * Recognized when the pointer is down and moved in the allowed direction.\r\n   * @constructor\r\n   * @extends AttrRecognizer\r\n   */\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\r\n     * @namespace\r\n     * @memberof PanRecognizer\r\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function () {\n      var direction = this.options.direction;\n      var actions = [];\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n      return actions;\n    },\n    directionTest: function (input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY;\n\n      // lock to axis?\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function (input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function (input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n      this._super.emit.call(this, input);\n    }\n  });\n\n  /**\r\n   * Pinch\r\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n   * @constructor\r\n   * @extends AttrRecognizer\r\n   */\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function (input) {\n      this._super.emit.call(this, input);\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        this.manager.emit(this.options.event + inOut, input);\n      }\n    }\n  });\n\n  /**\r\n   * Press\r\n   * Recognized when the pointer is down for x ms without any movement.\r\n   * @constructor\r\n   * @extends Recognizer\r\n   */\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n  inherit(PressRecognizer, Recognizer, {\n    /**\r\n     * @namespace\r\n     * @memberof PressRecognizer\r\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 500,\n      // minimal time of the pointer to be pressed\n      threshold: 5 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function () {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input;\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function (input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\r\n   * Rotate\r\n   * Recognized when two or more pointer are moving in a circular motion.\r\n   * @constructor\r\n   * @extends AttrRecognizer\r\n   */\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\r\n     * @namespace\r\n     * @memberof RotateRecognizer\r\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n\n  /**\r\n   * Swipe\r\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n   * @constructor\r\n   * @extends AttrRecognizer\r\n   */\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\r\n     * @namespace\r\n     * @memberof SwipeRecognizer\r\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.65,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function () {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function (input) {\n      var direction = this.options.direction;\n      var velocity;\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.velocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.velocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.velocityY;\n      }\n      return this._super.attrTest.call(this, input) && direction & input.direction && input.distance > this.options.threshold && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function (input) {\n      var direction = directionStr(input.direction);\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n      this.manager.emit(this.options.event, input);\n    }\n  });\n\n  /**\r\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n   * a single tap.\r\n   *\r\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n   * multi-taps being recognized.\r\n   * @constructor\r\n   * @extends Recognizer\r\n   */\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n  inherit(TapRecognizer, Recognizer, {\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 2,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function () {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      }\n\n      // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n        this._input = input;\n\n        // if tap count matches we have recognized it,\n        // else it has began recognizing...\n        var tapCount = this.count % options.taps;\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n      return STATE_FAILED;\n    },\n    failTimeout: function () {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function () {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n\n  /**\r\n   * Simple way to create an manager with a default set of recognizers.\r\n   * @param {HTMLElement} element\r\n   * @param {Object} [options]\r\n   * @constructor\r\n   */\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n\n  /**\r\n   * @const {string}\r\n   */\n  Hammer.VERSION = '2.0.4';\n\n  /**\r\n   * default settings\r\n   * @namespace\r\n   */\n  Hammer.defaults = {\n    /**\r\n     * set if DOM events are being triggered.\r\n     * But this is slower and unused by simple implementations, so disabled by default.\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\n    domEvents: false,\n    /**\r\n     * The value for the touchAction property/fallback.\r\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n     * @type {String}\r\n     * @default compute\r\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n    /**\r\n     * @type {Boolean}\r\n     * @default true\r\n     */\n    enable: true,\n    /**\r\n     * EXPERIMENTAL FEATURE -- can be removed/changed\r\n     * Change the parent input target element.\r\n     * If Null, then it is being set the to main element.\r\n     * @type {Null|EventTarget}\r\n     * @default null\r\n     */\n    inputTarget: null,\n    /**\r\n     * force an input class\r\n     * @type {Null|Function}\r\n     * @default null\r\n     */\n    inputClass: null,\n    /**\r\n     * Default recognizer setup when calling `Hammer()`\r\n     * When creating a new Manager these will be skipped.\r\n     * @type {Array}\r\n     */\n    preset: [\n    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n    /**\r\n     * Some CSS properties can be used to improve the working of Hammer.\r\n     * Add them to this method and they will be set when creating a new Manager.\r\n     * @namespace\r\n     */\n    cssProps: {\n      /**\r\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\r\n       * @type {String}\r\n       * @default 'none'\r\n       */\n      userSelect: 'none',\n      /**\r\n       * Disable the Windows Phone grippers when pressing an element.\r\n       * @type {String}\r\n       * @default 'none'\r\n       */\n      touchSelect: 'none',\n      /**\r\n       * Disables the default callout shown when you touch and hold a touch target.\r\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n       * a callout containing information about the link. This property allows you to disable that callout.\r\n       * @type {String}\r\n       * @default 'none'\r\n       */\n      touchCallout: 'none',\n      /**\r\n       * Specifies whether zooming is enabled. Used by IE10>\r\n       * @type {String}\r\n       * @default 'none'\r\n       */\n      contentZooming: 'none',\n      /**\r\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n       * @type {String}\r\n       * @default 'none'\r\n       */\n      userDrag: 'none',\n      /**\r\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n       * clickable element in iOS. This property obeys the alpha value, if specified.\r\n       * @type {String}\r\n       * @default 'rgba(0,0,0,0)'\r\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n\n  /**\r\n   * Manager\r\n   * @param {HTMLElement} element\r\n   * @param {Object} [options]\r\n   * @constructor\r\n   */\n  function Manager(element, options) {\n    options = options || {};\n    this.options = merge(options, Hammer.defaults);\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  Manager.prototype = {\n    /**\r\n     * set options\r\n     * @param {Object} options\r\n     * @returns {Manager}\r\n     */\n    set: function (options) {\n      extend(this.options, options);\n\n      // Options that need a little more setup\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n      return this;\n    },\n    /**\r\n     * stop recognizing for this session.\r\n     * This session will be discarded, when a new [input]start event is fired.\r\n     * When forced, the recognizer cycle is stopped immediately.\r\n     * @param {Boolean} [force]\r\n     */\n    stop: function (force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n    /**\r\n     * run the recognizers!\r\n     * called by the inputHandler function on every movement of the pointers (touches)\r\n     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n     * @param {Object} inputData\r\n     */\n    recognize: function (inputData) {\n      var session = this.session;\n      if (session.stopped) {\n        return;\n      }\n\n      // run the touch-action polyfill\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers;\n\n      // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n      var curRecognizer = session.curRecognizer;\n\n      // reset when the last recognizer is recognized\n      // or when we're in a new session\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n      var i = 0;\n      while (i < recognizers.length) {\n        recognizer = recognizers[i];\n\n        // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n        if (session.stopped !== FORCED_STOP && (\n        // 1\n        !curRecognizer || recognizer == curRecognizer ||\n        // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        }\n\n        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n        i++;\n      }\n    },\n    /**\r\n     * get a recognizer by its event name.\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Recognizer|Null}\r\n     */\n    get: function (recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n      var recognizers = this.recognizers;\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n      return null;\n    },\n    /**\r\n     * add a recognizer to the manager\r\n     * existing recognizers with the same event name will be removed\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer|Manager}\r\n     */\n    add: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      }\n\n      // remove existing\n      var existing = this.get(recognizer.options.event);\n      if (existing) {\n        this.remove(existing);\n      }\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n    /**\r\n     * remove a recognizer by name or instance\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Manager}\r\n     */\n    remove: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n      var recognizers = this.recognizers;\n      recognizer = this.get(recognizer);\n      recognizers.splice(inArray(recognizers, recognizer), 1);\n      this.touchAction.update();\n      return this;\n    },\n    /**\r\n     * bind event\r\n     * @param {String} events\r\n     * @param {Function} handler\r\n     * @returns {EventEmitter} this\r\n     */\n    on: function (events, handler) {\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n    /**\r\n     * unbind event, leave emit blank to remove all handlers\r\n     * @param {String} events\r\n     * @param {Function} [handler]\r\n     * @returns {EventEmitter} this\r\n     */\n    off: function (events, handler) {\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n    /**\r\n     * emit event to the listeners\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\n    emit: function (event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      }\n\n      // no handlers, so skip it all\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n      if (!handlers || !handlers.length) {\n        return;\n      }\n      data.type = event;\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n      var i = 0;\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n    /**\r\n     * destroy the manager and unbinds all events\r\n     * it doesn't unbind dom events, that is the user own responsibility\r\n     */\n    destroy: function () {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n\n  /**\r\n   * add/remove the css properties as defined in manager.options.cssProps\r\n   * @param {Manager} manager\r\n   * @param {Boolean} add\r\n   */\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n    each(manager.options.cssProps, function (value, name) {\n      element.style[prefixed(element.style, name)] = add ? value : '';\n    });\n  }\n\n  /**\r\n   * trigger dom event\r\n   * @param {String} event\r\n   * @param {Object} data\r\n   */\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n  extend(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  });\n  if (typeof define == TYPE_FUNCTION && define.amd) {\n    define(function () {\n      return Hammer;\n    });\n  } else if (typeof module != 'undefined' && module.exports) {\n    module.exports = Hammer;\n  } else {\n    window[exportName] = Hammer;\n  }\n})(window, document, 'Hammer');","map":{"version":3,"names":["window","document","exportName","undefined","VENDOR_PREFIXES","TEST_ELEMENT","createElement","TYPE_FUNCTION","round","Math","abs","now","Date","setTimeoutContext","fn","timeout","context","setTimeout","bindFn","invokeArrayArg","arg","Array","isArray","each","obj","iterator","i","forEach","length","call","hasOwnProperty","extend","dest","src","merge","keys","Object","inherit","child","base","properties","baseP","prototype","childP","create","constructor","_super","boundFn","apply","arguments","boolOrFn","val","args","ifUndefined","val1","val2","addEventListeners","target","types","handler","splitStr","type","addEventListener","removeEventListeners","removeEventListener","hasParent","node","parent","parentNode","inStr","str","find","indexOf","trim","split","inArray","findByKey","toArray","slice","uniqueArray","key","sort","results","values","push","sortUniqueArray","a","b","prefixed","property","prefix","prop","camelProp","toUpperCase","_uniqueId","uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","MOBILE_REGEX","SUPPORT_TOUCH","SUPPORT_POINTER_EVENTS","SUPPORT_ONLY_TOUCH","test","navigator","userAgent","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","COMPUTE_INTERVAL","INPUT_START","INPUT_MOVE","INPUT_END","INPUT_CANCEL","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","PROPS_XY","PROPS_CLIENT_XY","Input","manager","callback","self","options","inputTarget","domHandler","ev","enable","init","evEl","evTarget","evWin","destroy","createInputInstance","Type","inputClass","PointerEventInput","TouchInput","MouseInput","TouchMouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","isFinal","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","scale","getScale","rotation","getRotation","computeIntervalInputData","srcEvent","offset","offsetDelta","prevDelta","x","y","last","lastInterval","velocity","velocityX","velocityY","direction","v","getVelocity","clientX","clientY","p1","p2","props","sqrt","atan2","PI","start","end","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","MOUSE_ELEMENT_EVENTS","MOUSE_WINDOW_EVENTS","allow","pressed","MEhandler","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","MSPointerEvent","store","pointerEvents","PEhandler","removePointer","eventTypeNormalized","toLowerCase","replace","isTouch","storeIndex","pointerId","splice","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","SingleTouchInput","started","TEhandler","touches","normalizeSingleTouches","all","changed","changedTouches","concat","TOUCH_INPUT_MAP","TOUCH_TARGET_EVENTS","targetIds","MTEhandler","getTouches","allTouches","identifier","targetTouches","changedTargetTouches","filter","touch","mouse","TMEhandler","inputEvent","inputData","isMouse","PREFIXED_TOUCH_ACTION","style","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","TOUCH_ACTION_AUTO","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_NONE","TOUCH_ACTION_PAN_X","TOUCH_ACTION_PAN_Y","TouchAction","value","set","compute","actions","update","touchAction","recognizers","recognizer","getTouchAction","cleanTouchActions","join","preventDefaults","prevented","preventDefault","hasNone","hasPanY","hasPanX","preventSrc","STATE_POSSIBLE","STATE_BEGAN","STATE_CHANGED","STATE_ENDED","STATE_RECOGNIZED","STATE_CANCELLED","STATE_FAILED","Recognizer","id","defaults","state","simultaneous","requireFail","recognizeWith","otherRecognizer","getRecognizerByNameIfManager","dropRecognizeWith","requireFailure","dropRequireFailure","index","hasRequireFailures","canRecognizeWith","withState","event","stateStr","tryEmit","canEmit","inputDataClone","reset","process","directionStr","get","AttrRecognizer","attrTest","optionPointers","isRecognized","isValid","PanRecognizer","pX","pY","threshold","directionTest","hasMoved","PinchRecognizer","inOut","PressRecognizer","_timer","_input","time","validPointers","validMovement","validTime","clearTimeout","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","Hammer","preset","Manager","VERSION","domEvents","cssProps","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","STOP","FORCED_STOP","handlers","toggleCssProps","item","add","stop","force","stopped","curRecognizer","existing","remove","on","events","off","data","triggerDomEvent","name","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","Tap","Pan","Swipe","Pinch","Rotate","Press","define","amd","module","exports"],"sources":["E:/VR/node_modules/hammerjs/hammer.js"],"sourcesContent":["/*! Hammer.JS - v2.0.4 - 2014-09-28\r\n * http://hammerjs.github.io/\r\n *\r\n * Copyright (c) 2014 Jorik Tangelder;\r\n * Licensed under the MIT license */\r\n(function(window, document, exportName, undefined) {\r\n  'use strict';\r\n\r\nvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\r\nvar TEST_ELEMENT = document.createElement('div');\r\n\r\nvar TYPE_FUNCTION = 'function';\r\n\r\nvar round = Math.round;\r\nvar abs = Math.abs;\r\nvar now = Date.now;\r\n\r\n/**\r\n * set a timeout with a given scope\r\n * @param {Function} fn\r\n * @param {Number} timeout\r\n * @param {Object} context\r\n * @returns {number}\r\n */\r\nfunction setTimeoutContext(fn, timeout, context) {\r\n    return setTimeout(bindFn(fn, context), timeout);\r\n}\r\n\r\n/**\r\n * if the argument is an array, we want to execute the fn on each entry\r\n * if it aint an array we don't want to do a thing.\r\n * this is used by all the methods that accept a single and array argument.\r\n * @param {*|Array} arg\r\n * @param {String} fn\r\n * @param {Object} [context]\r\n * @returns {Boolean}\r\n */\r\nfunction invokeArrayArg(arg, fn, context) {\r\n    if (Array.isArray(arg)) {\r\n        each(arg, context[fn], context);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * walk objects and arrays\r\n * @param {Object} obj\r\n * @param {Function} iterator\r\n * @param {Object} context\r\n */\r\nfunction each(obj, iterator, context) {\r\n    var i;\r\n\r\n    if (!obj) {\r\n        return;\r\n    }\r\n\r\n    if (obj.forEach) {\r\n        obj.forEach(iterator, context);\r\n    } else if (obj.length !== undefined) {\r\n        i = 0;\r\n        while (i < obj.length) {\r\n            iterator.call(context, obj[i], i, obj);\r\n            i++;\r\n        }\r\n    } else {\r\n        for (i in obj) {\r\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * extend object.\r\n * means that properties in dest will be overwritten by the ones in src.\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @param {Boolean} [merge]\r\n * @returns {Object} dest\r\n */\r\nfunction extend(dest, src, merge) {\r\n    var keys = Object.keys(src);\r\n    var i = 0;\r\n    while (i < keys.length) {\r\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\r\n            dest[keys[i]] = src[keys[i]];\r\n        }\r\n        i++;\r\n    }\r\n    return dest;\r\n}\r\n\r\n/**\r\n * merge the values from src in the dest.\r\n * means that properties that exist in dest will not be overwritten by src\r\n * @param {Object} dest\r\n * @param {Object} src\r\n * @returns {Object} dest\r\n */\r\nfunction merge(dest, src) {\r\n    return extend(dest, src, true);\r\n}\r\n\r\n/**\r\n * simple class inheritance\r\n * @param {Function} child\r\n * @param {Function} base\r\n * @param {Object} [properties]\r\n */\r\nfunction inherit(child, base, properties) {\r\n    var baseP = base.prototype,\r\n        childP;\r\n\r\n    childP = child.prototype = Object.create(baseP);\r\n    childP.constructor = child;\r\n    childP._super = baseP;\r\n\r\n    if (properties) {\r\n        extend(childP, properties);\r\n    }\r\n}\r\n\r\n/**\r\n * simple function bind\r\n * @param {Function} fn\r\n * @param {Object} context\r\n * @returns {Function}\r\n */\r\nfunction bindFn(fn, context) {\r\n    return function boundFn() {\r\n        return fn.apply(context, arguments);\r\n    };\r\n}\r\n\r\n/**\r\n * let a boolean value also be a function that must return a boolean\r\n * this first item in args will be used as the context\r\n * @param {Boolean|Function} val\r\n * @param {Array} [args]\r\n * @returns {Boolean}\r\n */\r\nfunction boolOrFn(val, args) {\r\n    if (typeof val == TYPE_FUNCTION) {\r\n        return val.apply(args ? args[0] || undefined : undefined, args);\r\n    }\r\n    return val;\r\n}\r\n\r\n/**\r\n * use the val2 when val1 is undefined\r\n * @param {*} val1\r\n * @param {*} val2\r\n * @returns {*}\r\n */\r\nfunction ifUndefined(val1, val2) {\r\n    return (val1 === undefined) ? val2 : val1;\r\n}\r\n\r\n/**\r\n * addEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction addEventListeners(target, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        target.addEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * removeEventListener with multiple events at once\r\n * @param {EventTarget} target\r\n * @param {String} types\r\n * @param {Function} handler\r\n */\r\nfunction removeEventListeners(target, types, handler) {\r\n    each(splitStr(types), function(type) {\r\n        target.removeEventListener(type, handler, false);\r\n    });\r\n}\r\n\r\n/**\r\n * find if a node is in the given parent\r\n * @method hasParent\r\n * @param {HTMLElement} node\r\n * @param {HTMLElement} parent\r\n * @return {Boolean} found\r\n */\r\nfunction hasParent(node, parent) {\r\n    while (node) {\r\n        if (node == parent) {\r\n            return true;\r\n        }\r\n        node = node.parentNode;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * small indexOf wrapper\r\n * @param {String} str\r\n * @param {String} find\r\n * @returns {Boolean} found\r\n */\r\nfunction inStr(str, find) {\r\n    return str.indexOf(find) > -1;\r\n}\r\n\r\n/**\r\n * split string on whitespace\r\n * @param {String} str\r\n * @returns {Array} words\r\n */\r\nfunction splitStr(str) {\r\n    return str.trim().split(/\\s+/g);\r\n}\r\n\r\n/**\r\n * find if a array contains the object using indexOf or a simple polyFill\r\n * @param {Array} src\r\n * @param {String} find\r\n * @param {String} [findByKey]\r\n * @return {Boolean|Number} false when not found, or the index\r\n */\r\nfunction inArray(src, find, findByKey) {\r\n    if (src.indexOf && !findByKey) {\r\n        return src.indexOf(find);\r\n    } else {\r\n        var i = 0;\r\n        while (i < src.length) {\r\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\r\n                return i;\r\n            }\r\n            i++;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n/**\r\n * convert array-like objects to real arrays\r\n * @param {Object} obj\r\n * @returns {Array}\r\n */\r\nfunction toArray(obj) {\r\n    return Array.prototype.slice.call(obj, 0);\r\n}\r\n\r\n/**\r\n * unique array with objects based on a key (like 'id') or just by the array's value\r\n * @param {Array} src [{id:1},{id:2},{id:1}]\r\n * @param {String} [key]\r\n * @param {Boolean} [sort=False]\r\n * @returns {Array} [{id:1},{id:2}]\r\n */\r\nfunction uniqueArray(src, key, sort) {\r\n    var results = [];\r\n    var values = [];\r\n    var i = 0;\r\n\r\n    while (i < src.length) {\r\n        var val = key ? src[i][key] : src[i];\r\n        if (inArray(values, val) < 0) {\r\n            results.push(src[i]);\r\n        }\r\n        values[i] = val;\r\n        i++;\r\n    }\r\n\r\n    if (sort) {\r\n        if (!key) {\r\n            results = results.sort();\r\n        } else {\r\n            results = results.sort(function sortUniqueArray(a, b) {\r\n                return a[key] > b[key];\r\n            });\r\n        }\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * get the prefixed property\r\n * @param {Object} obj\r\n * @param {String} property\r\n * @returns {String|Undefined} prefixed\r\n */\r\nfunction prefixed(obj, property) {\r\n    var prefix, prop;\r\n    var camelProp = property[0].toUpperCase() + property.slice(1);\r\n\r\n    var i = 0;\r\n    while (i < VENDOR_PREFIXES.length) {\r\n        prefix = VENDOR_PREFIXES[i];\r\n        prop = (prefix) ? prefix + camelProp : property;\r\n\r\n        if (prop in obj) {\r\n            return prop;\r\n        }\r\n        i++;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * get a unique id\r\n * @returns {number} uniqueId\r\n */\r\nvar _uniqueId = 1;\r\nfunction uniqueId() {\r\n    return _uniqueId++;\r\n}\r\n\r\n/**\r\n * get the window object of an element\r\n * @param {HTMLElement} element\r\n * @returns {DocumentView|Window}\r\n */\r\nfunction getWindowForElement(element) {\r\n    var doc = element.ownerDocument;\r\n    return (doc.defaultView || doc.parentWindow);\r\n}\r\n\r\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\r\n\r\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\r\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\r\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\r\n\r\nvar INPUT_TYPE_TOUCH = 'touch';\r\nvar INPUT_TYPE_PEN = 'pen';\r\nvar INPUT_TYPE_MOUSE = 'mouse';\r\nvar INPUT_TYPE_KINECT = 'kinect';\r\n\r\nvar COMPUTE_INTERVAL = 25;\r\n\r\nvar INPUT_START = 1;\r\nvar INPUT_MOVE = 2;\r\nvar INPUT_END = 4;\r\nvar INPUT_CANCEL = 8;\r\n\r\nvar DIRECTION_NONE = 1;\r\nvar DIRECTION_LEFT = 2;\r\nvar DIRECTION_RIGHT = 4;\r\nvar DIRECTION_UP = 8;\r\nvar DIRECTION_DOWN = 16;\r\n\r\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\r\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\r\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\r\n\r\nvar PROPS_XY = ['x', 'y'];\r\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\r\n\r\n/**\r\n * create new input type manager\r\n * @param {Manager} manager\r\n * @param {Function} callback\r\n * @returns {Input}\r\n * @constructor\r\n */\r\nfunction Input(manager, callback) {\r\n    var self = this;\r\n    this.manager = manager;\r\n    this.callback = callback;\r\n    this.element = manager.element;\r\n    this.target = manager.options.inputTarget;\r\n\r\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\r\n    // so when disabled the input events are completely bypassed.\r\n    this.domHandler = function(ev) {\r\n        if (boolOrFn(manager.options.enable, [manager])) {\r\n            self.handler(ev);\r\n        }\r\n    };\r\n\r\n    this.init();\r\n\r\n}\r\n\r\nInput.prototype = {\r\n    /**\r\n     * should handle the inputEvent data and trigger the callback\r\n     * @virtual\r\n     */\r\n    handler: function() { },\r\n\r\n    /**\r\n     * bind the events\r\n     */\r\n    init: function() {\r\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\r\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\r\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n    },\r\n\r\n    /**\r\n     * unbind the events\r\n     */\r\n    destroy: function() {\r\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\r\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\r\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\r\n    }\r\n};\r\n\r\n/**\r\n * create new input type manager\r\n * called by the Manager constructor\r\n * @param {Hammer} manager\r\n * @returns {Input}\r\n */\r\nfunction createInputInstance(manager) {\r\n    var Type;\r\n    var inputClass = manager.options.inputClass;\r\n\r\n    if (inputClass) {\r\n        Type = inputClass;\r\n    } else if (SUPPORT_POINTER_EVENTS) {\r\n        Type = PointerEventInput;\r\n    } else if (SUPPORT_ONLY_TOUCH) {\r\n        Type = TouchInput;\r\n    } else if (!SUPPORT_TOUCH) {\r\n        Type = MouseInput;\r\n    } else {\r\n        Type = TouchMouseInput;\r\n    }\r\n    return new (Type)(manager, inputHandler);\r\n}\r\n\r\n/**\r\n * handle input events\r\n * @param {Manager} manager\r\n * @param {String} eventType\r\n * @param {Object} input\r\n */\r\nfunction inputHandler(manager, eventType, input) {\r\n    var pointersLen = input.pointers.length;\r\n    var changedPointersLen = input.changedPointers.length;\r\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\r\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\r\n\r\n    input.isFirst = !!isFirst;\r\n    input.isFinal = !!isFinal;\r\n\r\n    if (isFirst) {\r\n        manager.session = {};\r\n    }\r\n\r\n    // source event is the normalized value of the domEvents\r\n    // like 'touchstart, mouseup, pointerdown'\r\n    input.eventType = eventType;\r\n\r\n    // compute scale, rotation etc\r\n    computeInputData(manager, input);\r\n\r\n    // emit secret event\r\n    manager.emit('hammer.input', input);\r\n\r\n    manager.recognize(input);\r\n    manager.session.prevInput = input;\r\n}\r\n\r\n/**\r\n * extend the data with some usable properties like scale, rotate, velocity etc\r\n * @param {Object} manager\r\n * @param {Object} input\r\n */\r\nfunction computeInputData(manager, input) {\r\n    var session = manager.session;\r\n    var pointers = input.pointers;\r\n    var pointersLength = pointers.length;\r\n\r\n    // store the first input to calculate the distance and direction\r\n    if (!session.firstInput) {\r\n        session.firstInput = simpleCloneInputData(input);\r\n    }\r\n\r\n    // to compute scale and rotation we need to store the multiple touches\r\n    if (pointersLength > 1 && !session.firstMultiple) {\r\n        session.firstMultiple = simpleCloneInputData(input);\r\n    } else if (pointersLength === 1) {\r\n        session.firstMultiple = false;\r\n    }\r\n\r\n    var firstInput = session.firstInput;\r\n    var firstMultiple = session.firstMultiple;\r\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\r\n\r\n    var center = input.center = getCenter(pointers);\r\n    input.timeStamp = now();\r\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\r\n\r\n    input.angle = getAngle(offsetCenter, center);\r\n    input.distance = getDistance(offsetCenter, center);\r\n\r\n    computeDeltaXY(session, input);\r\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\r\n\r\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\r\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\r\n\r\n    computeIntervalInputData(session, input);\r\n\r\n    // find the correct target\r\n    var target = manager.element;\r\n    if (hasParent(input.srcEvent.target, target)) {\r\n        target = input.srcEvent.target;\r\n    }\r\n    input.target = target;\r\n}\r\n\r\nfunction computeDeltaXY(session, input) {\r\n    var center = input.center;\r\n    var offset = session.offsetDelta || {};\r\n    var prevDelta = session.prevDelta || {};\r\n    var prevInput = session.prevInput || {};\r\n\r\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\r\n        prevDelta = session.prevDelta = {\r\n            x: prevInput.deltaX || 0,\r\n            y: prevInput.deltaY || 0\r\n        };\r\n\r\n        offset = session.offsetDelta = {\r\n            x: center.x,\r\n            y: center.y\r\n        };\r\n    }\r\n\r\n    input.deltaX = prevDelta.x + (center.x - offset.x);\r\n    input.deltaY = prevDelta.y + (center.y - offset.y);\r\n}\r\n\r\n/**\r\n * velocity is calculated every x ms\r\n * @param {Object} session\r\n * @param {Object} input\r\n */\r\nfunction computeIntervalInputData(session, input) {\r\n    var last = session.lastInterval || input,\r\n        deltaTime = input.timeStamp - last.timeStamp,\r\n        velocity, velocityX, velocityY, direction;\r\n\r\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\r\n        var deltaX = last.deltaX - input.deltaX;\r\n        var deltaY = last.deltaY - input.deltaY;\r\n\r\n        var v = getVelocity(deltaTime, deltaX, deltaY);\r\n        velocityX = v.x;\r\n        velocityY = v.y;\r\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\r\n        direction = getDirection(deltaX, deltaY);\r\n\r\n        session.lastInterval = input;\r\n    } else {\r\n        // use latest velocity info if it doesn't overtake a minimum period\r\n        velocity = last.velocity;\r\n        velocityX = last.velocityX;\r\n        velocityY = last.velocityY;\r\n        direction = last.direction;\r\n    }\r\n\r\n    input.velocity = velocity;\r\n    input.velocityX = velocityX;\r\n    input.velocityY = velocityY;\r\n    input.direction = direction;\r\n}\r\n\r\n/**\r\n * create a simple clone from the input used for storage of firstInput and firstMultiple\r\n * @param {Object} input\r\n * @returns {Object} clonedInputData\r\n */\r\nfunction simpleCloneInputData(input) {\r\n    // make a simple copy of the pointers because we will get a reference if we don't\r\n    // we only need clientXY for the calculations\r\n    var pointers = [];\r\n    var i = 0;\r\n    while (i < input.pointers.length) {\r\n        pointers[i] = {\r\n            clientX: round(input.pointers[i].clientX),\r\n            clientY: round(input.pointers[i].clientY)\r\n        };\r\n        i++;\r\n    }\r\n\r\n    return {\r\n        timeStamp: now(),\r\n        pointers: pointers,\r\n        center: getCenter(pointers),\r\n        deltaX: input.deltaX,\r\n        deltaY: input.deltaY\r\n    };\r\n}\r\n\r\n/**\r\n * get the center of all the pointers\r\n * @param {Array} pointers\r\n * @return {Object} center contains `x` and `y` properties\r\n */\r\nfunction getCenter(pointers) {\r\n    var pointersLength = pointers.length;\r\n\r\n    // no need to loop when only one touch\r\n    if (pointersLength === 1) {\r\n        return {\r\n            x: round(pointers[0].clientX),\r\n            y: round(pointers[0].clientY)\r\n        };\r\n    }\r\n\r\n    var x = 0, y = 0, i = 0;\r\n    while (i < pointersLength) {\r\n        x += pointers[i].clientX;\r\n        y += pointers[i].clientY;\r\n        i++;\r\n    }\r\n\r\n    return {\r\n        x: round(x / pointersLength),\r\n        y: round(y / pointersLength)\r\n    };\r\n}\r\n\r\n/**\r\n * calculate the velocity between two points. unit is in px per ms.\r\n * @param {Number} deltaTime\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Object} velocity `x` and `y`\r\n */\r\nfunction getVelocity(deltaTime, x, y) {\r\n    return {\r\n        x: x / deltaTime || 0,\r\n        y: y / deltaTime || 0\r\n    };\r\n}\r\n\r\n/**\r\n * get the direction between two points\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @return {Number} direction\r\n */\r\nfunction getDirection(x, y) {\r\n    if (x === y) {\r\n        return DIRECTION_NONE;\r\n    }\r\n\r\n    if (abs(x) >= abs(y)) {\r\n        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n    }\r\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\r\n}\r\n\r\n/**\r\n * calculate the absolute distance between two points\r\n * @param {Object} p1 {x, y}\r\n * @param {Object} p2 {x, y}\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} distance\r\n */\r\nfunction getDistance(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n\r\n    return Math.sqrt((x * x) + (y * y));\r\n}\r\n\r\n/**\r\n * calculate the angle between two coordinates\r\n * @param {Object} p1\r\n * @param {Object} p2\r\n * @param {Array} [props] containing x and y keys\r\n * @return {Number} angle\r\n */\r\nfunction getAngle(p1, p2, props) {\r\n    if (!props) {\r\n        props = PROPS_XY;\r\n    }\r\n    var x = p2[props[0]] - p1[props[0]],\r\n        y = p2[props[1]] - p1[props[1]];\r\n    return Math.atan2(y, x) * 180 / Math.PI;\r\n}\r\n\r\n/**\r\n * calculate the rotation degrees between two pointersets\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} rotation\r\n */\r\nfunction getRotation(start, end) {\r\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\r\n}\r\n\r\n/**\r\n * calculate the scale factor between two pointersets\r\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\r\n * @param {Array} start array of pointers\r\n * @param {Array} end array of pointers\r\n * @return {Number} scale\r\n */\r\nfunction getScale(start, end) {\r\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\r\n}\r\n\r\nvar MOUSE_INPUT_MAP = {\r\n    mousedown: INPUT_START,\r\n    mousemove: INPUT_MOVE,\r\n    mouseup: INPUT_END\r\n};\r\n\r\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\r\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\r\n\r\n/**\r\n * Mouse events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction MouseInput() {\r\n    this.evEl = MOUSE_ELEMENT_EVENTS;\r\n    this.evWin = MOUSE_WINDOW_EVENTS;\r\n\r\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\r\n    this.pressed = false; // mousedown state\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(MouseInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function MEhandler(ev) {\r\n        var eventType = MOUSE_INPUT_MAP[ev.type];\r\n\r\n        // on start we want to have the left mouse button down\r\n        if (eventType & INPUT_START && ev.button === 0) {\r\n            this.pressed = true;\r\n        }\r\n\r\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\r\n            eventType = INPUT_END;\r\n        }\r\n\r\n        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\r\n        if (!this.pressed || !this.allow) {\r\n            return;\r\n        }\r\n\r\n        if (eventType & INPUT_END) {\r\n            this.pressed = false;\r\n        }\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: [ev],\r\n            changedPointers: [ev],\r\n            pointerType: INPUT_TYPE_MOUSE,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\nvar POINTER_INPUT_MAP = {\r\n    pointerdown: INPUT_START,\r\n    pointermove: INPUT_MOVE,\r\n    pointerup: INPUT_END,\r\n    pointercancel: INPUT_CANCEL,\r\n    pointerout: INPUT_CANCEL\r\n};\r\n\r\n// in IE10 the pointer types is defined as an enum\r\nvar IE10_POINTER_TYPE_ENUM = {\r\n    2: INPUT_TYPE_TOUCH,\r\n    3: INPUT_TYPE_PEN,\r\n    4: INPUT_TYPE_MOUSE,\r\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\r\n};\r\n\r\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\r\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\r\n\r\n// IE10 has prefixed support, and case-sensitive\r\nif (window.MSPointerEvent) {\r\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\r\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\r\n}\r\n\r\n/**\r\n * Pointer events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction PointerEventInput() {\r\n    this.evEl = POINTER_ELEMENT_EVENTS;\r\n    this.evWin = POINTER_WINDOW_EVENTS;\r\n\r\n    Input.apply(this, arguments);\r\n\r\n    this.store = (this.manager.session.pointerEvents = []);\r\n}\r\n\r\ninherit(PointerEventInput, Input, {\r\n    /**\r\n     * handle mouse events\r\n     * @param {Object} ev\r\n     */\r\n    handler: function PEhandler(ev) {\r\n        var store = this.store;\r\n        var removePointer = false;\r\n\r\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\r\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\r\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\r\n\r\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\r\n\r\n        // get index of the event in the store\r\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\r\n\r\n        // start and mouse must be down\r\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\r\n            if (storeIndex < 0) {\r\n                store.push(ev);\r\n                storeIndex = store.length - 1;\r\n            }\r\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\r\n            removePointer = true;\r\n        }\r\n\r\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\r\n        if (storeIndex < 0) {\r\n            return;\r\n        }\r\n\r\n        // update the event in the store\r\n        store[storeIndex] = ev;\r\n\r\n        this.callback(this.manager, eventType, {\r\n            pointers: store,\r\n            changedPointers: [ev],\r\n            pointerType: pointerType,\r\n            srcEvent: ev\r\n        });\r\n\r\n        if (removePointer) {\r\n            // remove from the store\r\n            store.splice(storeIndex, 1);\r\n        }\r\n    }\r\n});\r\n\r\nvar SINGLE_TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\r\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction SingleTouchInput() {\r\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\r\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\r\n    this.started = false;\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(SingleTouchInput, Input, {\r\n    handler: function TEhandler(ev) {\r\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\r\n\r\n        // should we handle the touch events?\r\n        if (type === INPUT_START) {\r\n            this.started = true;\r\n        }\r\n\r\n        if (!this.started) {\r\n            return;\r\n        }\r\n\r\n        var touches = normalizeSingleTouches.call(this, ev, type);\r\n\r\n        // when done, reset the started state\r\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\r\n            this.started = false;\r\n        }\r\n\r\n        this.callback(this.manager, type, {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\nfunction normalizeSingleTouches(ev, type) {\r\n    var all = toArray(ev.touches);\r\n    var changed = toArray(ev.changedTouches);\r\n\r\n    if (type & (INPUT_END | INPUT_CANCEL)) {\r\n        all = uniqueArray(all.concat(changed), 'identifier', true);\r\n    }\r\n\r\n    return [all, changed];\r\n}\r\n\r\nvar TOUCH_INPUT_MAP = {\r\n    touchstart: INPUT_START,\r\n    touchmove: INPUT_MOVE,\r\n    touchend: INPUT_END,\r\n    touchcancel: INPUT_CANCEL\r\n};\r\n\r\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\r\n\r\n/**\r\n * Multi-user touch events input\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchInput() {\r\n    this.evTarget = TOUCH_TARGET_EVENTS;\r\n    this.targetIds = {};\r\n\r\n    Input.apply(this, arguments);\r\n}\r\n\r\ninherit(TouchInput, Input, {\r\n    handler: function MTEhandler(ev) {\r\n        var type = TOUCH_INPUT_MAP[ev.type];\r\n        var touches = getTouches.call(this, ev, type);\r\n        if (!touches) {\r\n            return;\r\n        }\r\n\r\n        this.callback(this.manager, type, {\r\n            pointers: touches[0],\r\n            changedPointers: touches[1],\r\n            pointerType: INPUT_TYPE_TOUCH,\r\n            srcEvent: ev\r\n        });\r\n    }\r\n});\r\n\r\n/**\r\n * @this {TouchInput}\r\n * @param {Object} ev\r\n * @param {Number} type flag\r\n * @returns {undefined|Array} [all, changed]\r\n */\r\nfunction getTouches(ev, type) {\r\n    var allTouches = toArray(ev.touches);\r\n    var targetIds = this.targetIds;\r\n\r\n    // when there is only one touch, the process can be simplified\r\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\r\n        targetIds[allTouches[0].identifier] = true;\r\n        return [allTouches, allTouches];\r\n    }\r\n\r\n    var i,\r\n        targetTouches,\r\n        changedTouches = toArray(ev.changedTouches),\r\n        changedTargetTouches = [],\r\n        target = this.target;\r\n\r\n    // get target touches from touches\r\n    targetTouches = allTouches.filter(function(touch) {\r\n        return hasParent(touch.target, target);\r\n    });\r\n\r\n    // collect touches\r\n    if (type === INPUT_START) {\r\n        i = 0;\r\n        while (i < targetTouches.length) {\r\n            targetIds[targetTouches[i].identifier] = true;\r\n            i++;\r\n        }\r\n    }\r\n\r\n    // filter changed touches to only contain touches that exist in the collected target ids\r\n    i = 0;\r\n    while (i < changedTouches.length) {\r\n        if (targetIds[changedTouches[i].identifier]) {\r\n            changedTargetTouches.push(changedTouches[i]);\r\n        }\r\n\r\n        // cleanup removed touches\r\n        if (type & (INPUT_END | INPUT_CANCEL)) {\r\n            delete targetIds[changedTouches[i].identifier];\r\n        }\r\n        i++;\r\n    }\r\n\r\n    if (!changedTargetTouches.length) {\r\n        return;\r\n    }\r\n\r\n    return [\r\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\r\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\r\n        changedTargetTouches\r\n    ];\r\n}\r\n\r\n/**\r\n * Combined touch and mouse input\r\n *\r\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\r\n * This because touch devices also emit mouse events while doing a touch.\r\n *\r\n * @constructor\r\n * @extends Input\r\n */\r\nfunction TouchMouseInput() {\r\n    Input.apply(this, arguments);\r\n\r\n    var handler = bindFn(this.handler, this);\r\n    this.touch = new TouchInput(this.manager, handler);\r\n    this.mouse = new MouseInput(this.manager, handler);\r\n}\r\n\r\ninherit(TouchMouseInput, Input, {\r\n    /**\r\n     * handle mouse and touch events\r\n     * @param {Hammer} manager\r\n     * @param {String} inputEvent\r\n     * @param {Object} inputData\r\n     */\r\n    handler: function TMEhandler(manager, inputEvent, inputData) {\r\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\r\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\r\n\r\n        // when we're in a touch event, so  block all upcoming mouse events\r\n        // most mobile browser also emit mouseevents, right after touchstart\r\n        if (isTouch) {\r\n            this.mouse.allow = false;\r\n        } else if (isMouse && !this.mouse.allow) {\r\n            return;\r\n        }\r\n\r\n        // reset the allowMouse when we're done\r\n        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\r\n            this.mouse.allow = true;\r\n        }\r\n\r\n        this.callback(manager, inputEvent, inputData);\r\n    },\r\n\r\n    /**\r\n     * remove the event listeners\r\n     */\r\n    destroy: function destroy() {\r\n        this.touch.destroy();\r\n        this.mouse.destroy();\r\n    }\r\n});\r\n\r\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\r\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\r\n\r\n// magical touchAction value\r\nvar TOUCH_ACTION_COMPUTE = 'compute';\r\nvar TOUCH_ACTION_AUTO = 'auto';\r\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\r\nvar TOUCH_ACTION_NONE = 'none';\r\nvar TOUCH_ACTION_PAN_X = 'pan-x';\r\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\r\n\r\n/**\r\n * Touch Action\r\n * sets the touchAction property or uses the js alternative\r\n * @param {Manager} manager\r\n * @param {String} value\r\n * @constructor\r\n */\r\nfunction TouchAction(manager, value) {\r\n    this.manager = manager;\r\n    this.set(value);\r\n}\r\n\r\nTouchAction.prototype = {\r\n    /**\r\n     * set the touchAction value on the element or enable the polyfill\r\n     * @param {String} value\r\n     */\r\n    set: function(value) {\r\n        // find out the touch-action by the event handlers\r\n        if (value == TOUCH_ACTION_COMPUTE) {\r\n            value = this.compute();\r\n        }\r\n\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\r\n        }\r\n        this.actions = value.toLowerCase().trim();\r\n    },\r\n\r\n    /**\r\n     * just re-set the touchAction value\r\n     */\r\n    update: function() {\r\n        this.set(this.manager.options.touchAction);\r\n    },\r\n\r\n    /**\r\n     * compute the value for the touchAction property based on the recognizer's settings\r\n     * @returns {String} value\r\n     */\r\n    compute: function() {\r\n        var actions = [];\r\n        each(this.manager.recognizers, function(recognizer) {\r\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\r\n                actions = actions.concat(recognizer.getTouchAction());\r\n            }\r\n        });\r\n        return cleanTouchActions(actions.join(' '));\r\n    },\r\n\r\n    /**\r\n     * this method is called on each input cycle and provides the preventing of the browser behavior\r\n     * @param {Object} input\r\n     */\r\n    preventDefaults: function(input) {\r\n        // not needed with native support for the touchAction property\r\n        if (NATIVE_TOUCH_ACTION) {\r\n            return;\r\n        }\r\n\r\n        var srcEvent = input.srcEvent;\r\n        var direction = input.offsetDirection;\r\n\r\n        // if the touch action did prevented once this session\r\n        if (this.manager.session.prevented) {\r\n            srcEvent.preventDefault();\r\n            return;\r\n        }\r\n\r\n        var actions = this.actions;\r\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\r\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n\r\n        if (hasNone ||\r\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\r\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\r\n            return this.preventSrc(srcEvent);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\r\n     * @param {Object} srcEvent\r\n     */\r\n    preventSrc: function(srcEvent) {\r\n        this.manager.session.prevented = true;\r\n        srcEvent.preventDefault();\r\n    }\r\n};\r\n\r\n/**\r\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\r\n * @param {String} actions\r\n * @returns {*}\r\n */\r\nfunction cleanTouchActions(actions) {\r\n    // none\r\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\r\n        return TOUCH_ACTION_NONE;\r\n    }\r\n\r\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\r\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\r\n\r\n    // pan-x and pan-y can be combined\r\n    if (hasPanX && hasPanY) {\r\n        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\r\n    }\r\n\r\n    // pan-x OR pan-y\r\n    if (hasPanX || hasPanY) {\r\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\r\n    }\r\n\r\n    // manipulation\r\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\r\n        return TOUCH_ACTION_MANIPULATION;\r\n    }\r\n\r\n    return TOUCH_ACTION_AUTO;\r\n}\r\n\r\n/**\r\n * Recognizer flow explained; *\r\n * All recognizers have the initial state of POSSIBLE when a input session starts.\r\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\r\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\r\n *\r\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\r\n * which determines with state it should be.\r\n *\r\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\r\n * POSSIBLE to give it another change on the next cycle.\r\n *\r\n *               Possible\r\n *                  |\r\n *            +-----+---------------+\r\n *            |                     |\r\n *      +-----+-----+               |\r\n *      |           |               |\r\n *   Failed      Cancelled          |\r\n *                          +-------+------+\r\n *                          |              |\r\n *                      Recognized       Began\r\n *                                         |\r\n *                                      Changed\r\n *                                         |\r\n *                                  Ended/Recognized\r\n */\r\nvar STATE_POSSIBLE = 1;\r\nvar STATE_BEGAN = 2;\r\nvar STATE_CHANGED = 4;\r\nvar STATE_ENDED = 8;\r\nvar STATE_RECOGNIZED = STATE_ENDED;\r\nvar STATE_CANCELLED = 16;\r\nvar STATE_FAILED = 32;\r\n\r\n/**\r\n * Recognizer\r\n * Every recognizer needs to extend from this class.\r\n * @constructor\r\n * @param {Object} options\r\n */\r\nfunction Recognizer(options) {\r\n    this.id = uniqueId();\r\n\r\n    this.manager = null;\r\n    this.options = merge(options || {}, this.defaults);\r\n\r\n    // default is enable true\r\n    this.options.enable = ifUndefined(this.options.enable, true);\r\n\r\n    this.state = STATE_POSSIBLE;\r\n\r\n    this.simultaneous = {};\r\n    this.requireFail = [];\r\n}\r\n\r\nRecognizer.prototype = {\r\n    /**\r\n     * @virtual\r\n     * @type {Object}\r\n     */\r\n    defaults: {},\r\n\r\n    /**\r\n     * set options\r\n     * @param {Object} options\r\n     * @return {Recognizer}\r\n     */\r\n    set: function(options) {\r\n        extend(this.options, options);\r\n\r\n        // also update the touchAction, in case something changed about the directions/enabled state\r\n        this.manager && this.manager.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognize simultaneous with an other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    recognizeWith: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\r\n            return this;\r\n        }\r\n\r\n        var simultaneous = this.simultaneous;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (!simultaneous[otherRecognizer.id]) {\r\n            simultaneous[otherRecognizer.id] = otherRecognizer;\r\n            otherRecognizer.recognizeWith(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRecognizeWith: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\r\n            return this;\r\n        }\r\n\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        delete this.simultaneous[otherRecognizer.id];\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * recognizer can only run when an other is failing\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    requireFailure: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\r\n            return this;\r\n        }\r\n\r\n        var requireFail = this.requireFail;\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        if (inArray(requireFail, otherRecognizer) === -1) {\r\n            requireFail.push(otherRecognizer);\r\n            otherRecognizer.requireFailure(this);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Recognizer} this\r\n     */\r\n    dropRequireFailure: function(otherRecognizer) {\r\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\r\n            return this;\r\n        }\r\n\r\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\r\n        var index = inArray(this.requireFail, otherRecognizer);\r\n        if (index > -1) {\r\n            this.requireFail.splice(index, 1);\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * has require failures boolean\r\n     * @returns {boolean}\r\n     */\r\n    hasRequireFailures: function() {\r\n        return this.requireFail.length > 0;\r\n    },\r\n\r\n    /**\r\n     * if the recognizer can recognize simultaneous with an other recognizer\r\n     * @param {Recognizer} otherRecognizer\r\n     * @returns {Boolean}\r\n     */\r\n    canRecognizeWith: function(otherRecognizer) {\r\n        return !!this.simultaneous[otherRecognizer.id];\r\n    },\r\n\r\n    /**\r\n     * You should use `tryEmit` instead of `emit` directly to check\r\n     * that all the needed recognizers has failed before emitting.\r\n     * @param {Object} input\r\n     */\r\n    emit: function(input) {\r\n        var self = this;\r\n        var state = this.state;\r\n\r\n        function emit(withState) {\r\n            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\r\n        }\r\n\r\n        // 'panstart' and 'panmove'\r\n        if (state < STATE_ENDED) {\r\n            emit(true);\r\n        }\r\n\r\n        emit(); // simple 'eventName' events\r\n\r\n        // panend and pancancel\r\n        if (state >= STATE_ENDED) {\r\n            emit(true);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check that all the require failure recognizers has failed,\r\n     * if true, it emits a gesture event,\r\n     * otherwise, setup the state to FAILED.\r\n     * @param {Object} input\r\n     */\r\n    tryEmit: function(input) {\r\n        if (this.canEmit()) {\r\n            return this.emit(input);\r\n        }\r\n        // it's failing anyway\r\n        this.state = STATE_FAILED;\r\n    },\r\n\r\n    /**\r\n     * can we emit?\r\n     * @returns {boolean}\r\n     */\r\n    canEmit: function() {\r\n        var i = 0;\r\n        while (i < this.requireFail.length) {\r\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\r\n                return false;\r\n            }\r\n            i++;\r\n        }\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * update the recognizer\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        // make a new copy of the inputData\r\n        // so we can change the inputData without messing up the other recognizers\r\n        var inputDataClone = extend({}, inputData);\r\n\r\n        // is is enabled and allow recognizing?\r\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\r\n            this.reset();\r\n            this.state = STATE_FAILED;\r\n            return;\r\n        }\r\n\r\n        // reset when we've reached the end\r\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\r\n            this.state = STATE_POSSIBLE;\r\n        }\r\n\r\n        this.state = this.process(inputDataClone);\r\n\r\n        // the recognizer has recognized a gesture\r\n        // so trigger an event\r\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\r\n            this.tryEmit(inputDataClone);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * return the state of the recognizer\r\n     * the actual recognizing happens in this method\r\n     * @virtual\r\n     * @param {Object} inputData\r\n     * @returns {Const} STATE\r\n     */\r\n    process: function(inputData) { }, // jshint ignore:line\r\n\r\n    /**\r\n     * return the preferred touch-action\r\n     * @virtual\r\n     * @returns {Array}\r\n     */\r\n    getTouchAction: function() { },\r\n\r\n    /**\r\n     * called when the gesture isn't allowed to recognize\r\n     * like when another is being recognized or it is disabled\r\n     * @virtual\r\n     */\r\n    reset: function() { }\r\n};\r\n\r\n/**\r\n * get a usable string, used as event postfix\r\n * @param {Const} state\r\n * @returns {String} state\r\n */\r\nfunction stateStr(state) {\r\n    if (state & STATE_CANCELLED) {\r\n        return 'cancel';\r\n    } else if (state & STATE_ENDED) {\r\n        return 'end';\r\n    } else if (state & STATE_CHANGED) {\r\n        return 'move';\r\n    } else if (state & STATE_BEGAN) {\r\n        return 'start';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * direction cons to string\r\n * @param {Const} direction\r\n * @returns {String}\r\n */\r\nfunction directionStr(direction) {\r\n    if (direction == DIRECTION_DOWN) {\r\n        return 'down';\r\n    } else if (direction == DIRECTION_UP) {\r\n        return 'up';\r\n    } else if (direction == DIRECTION_LEFT) {\r\n        return 'left';\r\n    } else if (direction == DIRECTION_RIGHT) {\r\n        return 'right';\r\n    }\r\n    return '';\r\n}\r\n\r\n/**\r\n * get a recognizer by name if it is bound to a manager\r\n * @param {Recognizer|String} otherRecognizer\r\n * @param {Recognizer} recognizer\r\n * @returns {Recognizer}\r\n */\r\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\r\n    var manager = recognizer.manager;\r\n    if (manager) {\r\n        return manager.get(otherRecognizer);\r\n    }\r\n    return otherRecognizer;\r\n}\r\n\r\n/**\r\n * This recognizer is just used as a base for the simple attribute recognizers.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction AttrRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(AttrRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof AttrRecognizer\r\n     */\r\n    defaults: {\r\n        /**\r\n         * @type {Number}\r\n         * @default 1\r\n         */\r\n        pointers: 1\r\n    },\r\n\r\n    /**\r\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {Boolean} recognized\r\n     */\r\n    attrTest: function(input) {\r\n        var optionPointers = this.options.pointers;\r\n        return optionPointers === 0 || input.pointers.length === optionPointers;\r\n    },\r\n\r\n    /**\r\n     * Process the input and return the state for the recognizer\r\n     * @memberof AttrRecognizer\r\n     * @param {Object} input\r\n     * @returns {*} State\r\n     */\r\n    process: function(input) {\r\n        var state = this.state;\r\n        var eventType = input.eventType;\r\n\r\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\r\n        var isValid = this.attrTest(input);\r\n\r\n        // on cancel input and we've recognized before, return STATE_CANCELLED\r\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\r\n            return state | STATE_CANCELLED;\r\n        } else if (isRecognized || isValid) {\r\n            if (eventType & INPUT_END) {\r\n                return state | STATE_ENDED;\r\n            } else if (!(state & STATE_BEGAN)) {\r\n                return STATE_BEGAN;\r\n            }\r\n            return state | STATE_CHANGED;\r\n        }\r\n        return STATE_FAILED;\r\n    }\r\n});\r\n\r\n/**\r\n * Pan\r\n * Recognized when the pointer is down and moved in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PanRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n\r\n    this.pX = null;\r\n    this.pY = null;\r\n}\r\n\r\ninherit(PanRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PanRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pan',\r\n        threshold: 10,\r\n        pointers: 1,\r\n        direction: DIRECTION_ALL\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        var direction = this.options.direction;\r\n        var actions = [];\r\n        if (direction & DIRECTION_HORIZONTAL) {\r\n            actions.push(TOUCH_ACTION_PAN_Y);\r\n        }\r\n        if (direction & DIRECTION_VERTICAL) {\r\n            actions.push(TOUCH_ACTION_PAN_X);\r\n        }\r\n        return actions;\r\n    },\r\n\r\n    directionTest: function(input) {\r\n        var options = this.options;\r\n        var hasMoved = true;\r\n        var distance = input.distance;\r\n        var direction = input.direction;\r\n        var x = input.deltaX;\r\n        var y = input.deltaY;\r\n\r\n        // lock to axis?\r\n        if (!(direction & options.direction)) {\r\n            if (options.direction & DIRECTION_HORIZONTAL) {\r\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n                hasMoved = x != this.pX;\r\n                distance = Math.abs(input.deltaX);\r\n            } else {\r\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\r\n                hasMoved = y != this.pY;\r\n                distance = Math.abs(input.deltaY);\r\n            }\r\n        }\r\n        input.direction = direction;\r\n        return hasMoved && distance > options.threshold && direction & options.direction;\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\r\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\r\n    },\r\n\r\n    emit: function(input) {\r\n        this.pX = input.deltaX;\r\n        this.pY = input.deltaY;\r\n\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n\r\n        this._super.emit.call(this, input);\r\n    }\r\n});\r\n\r\n/**\r\n * Pinch\r\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction PinchRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(PinchRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'pinch',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\r\n    },\r\n\r\n    emit: function(input) {\r\n        this._super.emit.call(this, input);\r\n        if (input.scale !== 1) {\r\n            var inOut = input.scale < 1 ? 'in' : 'out';\r\n            this.manager.emit(this.options.event + inOut, input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Press\r\n * Recognized when the pointer is down for x ms without any movement.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction PressRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n}\r\n\r\ninherit(PressRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PressRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'press',\r\n        pointers: 1,\r\n        time: 500, // minimal time of the pointer to be pressed\r\n        threshold: 5 // a minimal movement is ok, but keep it low\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_AUTO];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTime = input.deltaTime > options.time;\r\n\r\n        this._input = input;\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\r\n            this.reset();\r\n        } else if (input.eventType & INPUT_START) {\r\n            this.reset();\r\n            this._timer = setTimeoutContext(function() {\r\n                this.state = STATE_RECOGNIZED;\r\n                this.tryEmit();\r\n            }, options.time, this);\r\n        } else if (input.eventType & INPUT_END) {\r\n            return STATE_RECOGNIZED;\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function(input) {\r\n        if (this.state !== STATE_RECOGNIZED) {\r\n            return;\r\n        }\r\n\r\n        if (input && (input.eventType & INPUT_END)) {\r\n            this.manager.emit(this.options.event + 'up', input);\r\n        } else {\r\n            this._input.timeStamp = now();\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Rotate\r\n * Recognized when two or more pointer are moving in a circular motion.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction RotateRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(RotateRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof RotateRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'rotate',\r\n        threshold: 0,\r\n        pointers: 2\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_NONE];\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        return this._super.attrTest.call(this, input) &&\r\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\r\n    }\r\n});\r\n\r\n/**\r\n * Swipe\r\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\r\n * @constructor\r\n * @extends AttrRecognizer\r\n */\r\nfunction SwipeRecognizer() {\r\n    AttrRecognizer.apply(this, arguments);\r\n}\r\n\r\ninherit(SwipeRecognizer, AttrRecognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof SwipeRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'swipe',\r\n        threshold: 10,\r\n        velocity: 0.65,\r\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\r\n        pointers: 1\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return PanRecognizer.prototype.getTouchAction.call(this);\r\n    },\r\n\r\n    attrTest: function(input) {\r\n        var direction = this.options.direction;\r\n        var velocity;\r\n\r\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\r\n            velocity = input.velocity;\r\n        } else if (direction & DIRECTION_HORIZONTAL) {\r\n            velocity = input.velocityX;\r\n        } else if (direction & DIRECTION_VERTICAL) {\r\n            velocity = input.velocityY;\r\n        }\r\n\r\n        return this._super.attrTest.call(this, input) &&\r\n            direction & input.direction &&\r\n            input.distance > this.options.threshold &&\r\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\r\n    },\r\n\r\n    emit: function(input) {\r\n        var direction = directionStr(input.direction);\r\n        if (direction) {\r\n            this.manager.emit(this.options.event + direction, input);\r\n        }\r\n\r\n        this.manager.emit(this.options.event, input);\r\n    }\r\n});\r\n\r\n/**\r\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\r\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\r\n * a single tap.\r\n *\r\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\r\n * multi-taps being recognized.\r\n * @constructor\r\n * @extends Recognizer\r\n */\r\nfunction TapRecognizer() {\r\n    Recognizer.apply(this, arguments);\r\n\r\n    // previous time and center,\r\n    // used for tap counting\r\n    this.pTime = false;\r\n    this.pCenter = false;\r\n\r\n    this._timer = null;\r\n    this._input = null;\r\n    this.count = 0;\r\n}\r\n\r\ninherit(TapRecognizer, Recognizer, {\r\n    /**\r\n     * @namespace\r\n     * @memberof PinchRecognizer\r\n     */\r\n    defaults: {\r\n        event: 'tap',\r\n        pointers: 1,\r\n        taps: 1,\r\n        interval: 300, // max time between the multi-tap taps\r\n        time: 250, // max time of the pointer to be down (like finger on the screen)\r\n        threshold: 2, // a minimal movement is ok, but keep it low\r\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\r\n    },\r\n\r\n    getTouchAction: function() {\r\n        return [TOUCH_ACTION_MANIPULATION];\r\n    },\r\n\r\n    process: function(input) {\r\n        var options = this.options;\r\n\r\n        var validPointers = input.pointers.length === options.pointers;\r\n        var validMovement = input.distance < options.threshold;\r\n        var validTouchTime = input.deltaTime < options.time;\r\n\r\n        this.reset();\r\n\r\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\r\n            return this.failTimeout();\r\n        }\r\n\r\n        // we only allow little movement\r\n        // and we've reached an end event, so a tap is possible\r\n        if (validMovement && validTouchTime && validPointers) {\r\n            if (input.eventType != INPUT_END) {\r\n                return this.failTimeout();\r\n            }\r\n\r\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\r\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\r\n\r\n            this.pTime = input.timeStamp;\r\n            this.pCenter = input.center;\r\n\r\n            if (!validMultiTap || !validInterval) {\r\n                this.count = 1;\r\n            } else {\r\n                this.count += 1;\r\n            }\r\n\r\n            this._input = input;\r\n\r\n            // if tap count matches we have recognized it,\r\n            // else it has began recognizing...\r\n            var tapCount = this.count % options.taps;\r\n            if (tapCount === 0) {\r\n                // no failing requirements, immediately trigger the tap event\r\n                // or wait as long as the multitap interval to trigger\r\n                if (!this.hasRequireFailures()) {\r\n                    return STATE_RECOGNIZED;\r\n                } else {\r\n                    this._timer = setTimeoutContext(function() {\r\n                        this.state = STATE_RECOGNIZED;\r\n                        this.tryEmit();\r\n                    }, options.interval, this);\r\n                    return STATE_BEGAN;\r\n                }\r\n            }\r\n        }\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    failTimeout: function() {\r\n        this._timer = setTimeoutContext(function() {\r\n            this.state = STATE_FAILED;\r\n        }, this.options.interval, this);\r\n        return STATE_FAILED;\r\n    },\r\n\r\n    reset: function() {\r\n        clearTimeout(this._timer);\r\n    },\r\n\r\n    emit: function() {\r\n        if (this.state == STATE_RECOGNIZED ) {\r\n            this._input.tapCount = this.count;\r\n            this.manager.emit(this.options.event, this._input);\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Simple way to create an manager with a default set of recognizers.\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Hammer(element, options) {\r\n    options = options || {};\r\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\r\n    return new Manager(element, options);\r\n}\r\n\r\n/**\r\n * @const {string}\r\n */\r\nHammer.VERSION = '2.0.4';\r\n\r\n/**\r\n * default settings\r\n * @namespace\r\n */\r\nHammer.defaults = {\r\n    /**\r\n     * set if DOM events are being triggered.\r\n     * But this is slower and unused by simple implementations, so disabled by default.\r\n     * @type {Boolean}\r\n     * @default false\r\n     */\r\n    domEvents: false,\r\n\r\n    /**\r\n     * The value for the touchAction property/fallback.\r\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\r\n     * @type {String}\r\n     * @default compute\r\n     */\r\n    touchAction: TOUCH_ACTION_COMPUTE,\r\n\r\n    /**\r\n     * @type {Boolean}\r\n     * @default true\r\n     */\r\n    enable: true,\r\n\r\n    /**\r\n     * EXPERIMENTAL FEATURE -- can be removed/changed\r\n     * Change the parent input target element.\r\n     * If Null, then it is being set the to main element.\r\n     * @type {Null|EventTarget}\r\n     * @default null\r\n     */\r\n    inputTarget: null,\r\n\r\n    /**\r\n     * force an input class\r\n     * @type {Null|Function}\r\n     * @default null\r\n     */\r\n    inputClass: null,\r\n\r\n    /**\r\n     * Default recognizer setup when calling `Hammer()`\r\n     * When creating a new Manager these will be skipped.\r\n     * @type {Array}\r\n     */\r\n    preset: [\r\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\r\n        [RotateRecognizer, { enable: false }],\r\n        [PinchRecognizer, { enable: false }, ['rotate']],\r\n        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\r\n        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\r\n        [TapRecognizer],\r\n        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\r\n        [PressRecognizer]\r\n    ],\r\n\r\n    /**\r\n     * Some CSS properties can be used to improve the working of Hammer.\r\n     * Add them to this method and they will be set when creating a new Manager.\r\n     * @namespace\r\n     */\r\n    cssProps: {\r\n        /**\r\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userSelect: 'none',\r\n\r\n        /**\r\n         * Disable the Windows Phone grippers when pressing an element.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchSelect: 'none',\r\n\r\n        /**\r\n         * Disables the default callout shown when you touch and hold a touch target.\r\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\r\n         * a callout containing information about the link. This property allows you to disable that callout.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        touchCallout: 'none',\r\n\r\n        /**\r\n         * Specifies whether zooming is enabled. Used by IE10>\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        contentZooming: 'none',\r\n\r\n        /**\r\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\r\n         * @type {String}\r\n         * @default 'none'\r\n         */\r\n        userDrag: 'none',\r\n\r\n        /**\r\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\r\n         * clickable element in iOS. This property obeys the alpha value, if specified.\r\n         * @type {String}\r\n         * @default 'rgba(0,0,0,0)'\r\n         */\r\n        tapHighlightColor: 'rgba(0,0,0,0)'\r\n    }\r\n};\r\n\r\nvar STOP = 1;\r\nvar FORCED_STOP = 2;\r\n\r\n/**\r\n * Manager\r\n * @param {HTMLElement} element\r\n * @param {Object} [options]\r\n * @constructor\r\n */\r\nfunction Manager(element, options) {\r\n    options = options || {};\r\n\r\n    this.options = merge(options, Hammer.defaults);\r\n    this.options.inputTarget = this.options.inputTarget || element;\r\n\r\n    this.handlers = {};\r\n    this.session = {};\r\n    this.recognizers = [];\r\n\r\n    this.element = element;\r\n    this.input = createInputInstance(this);\r\n    this.touchAction = new TouchAction(this, this.options.touchAction);\r\n\r\n    toggleCssProps(this, true);\r\n\r\n    each(options.recognizers, function(item) {\r\n        var recognizer = this.add(new (item[0])(item[1]));\r\n        item[2] && recognizer.recognizeWith(item[2]);\r\n        item[3] && recognizer.requireFailure(item[3]);\r\n    }, this);\r\n}\r\n\r\nManager.prototype = {\r\n    /**\r\n     * set options\r\n     * @param {Object} options\r\n     * @returns {Manager}\r\n     */\r\n    set: function(options) {\r\n        extend(this.options, options);\r\n\r\n        // Options that need a little more setup\r\n        if (options.touchAction) {\r\n            this.touchAction.update();\r\n        }\r\n        if (options.inputTarget) {\r\n            // Clean up existing event listeners and reinitialize\r\n            this.input.destroy();\r\n            this.input.target = options.inputTarget;\r\n            this.input.init();\r\n        }\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * stop recognizing for this session.\r\n     * This session will be discarded, when a new [input]start event is fired.\r\n     * When forced, the recognizer cycle is stopped immediately.\r\n     * @param {Boolean} [force]\r\n     */\r\n    stop: function(force) {\r\n        this.session.stopped = force ? FORCED_STOP : STOP;\r\n    },\r\n\r\n    /**\r\n     * run the recognizers!\r\n     * called by the inputHandler function on every movement of the pointers (touches)\r\n     * it walks through all the recognizers and tries to detect the gesture that is being made\r\n     * @param {Object} inputData\r\n     */\r\n    recognize: function(inputData) {\r\n        var session = this.session;\r\n        if (session.stopped) {\r\n            return;\r\n        }\r\n\r\n        // run the touch-action polyfill\r\n        this.touchAction.preventDefaults(inputData);\r\n\r\n        var recognizer;\r\n        var recognizers = this.recognizers;\r\n\r\n        // this holds the recognizer that is being recognized.\r\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\r\n        // if no recognizer is detecting a thing, it is set to `null`\r\n        var curRecognizer = session.curRecognizer;\r\n\r\n        // reset when the last recognizer is recognized\r\n        // or when we're in a new session\r\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\r\n            curRecognizer = session.curRecognizer = null;\r\n        }\r\n\r\n        var i = 0;\r\n        while (i < recognizers.length) {\r\n            recognizer = recognizers[i];\r\n\r\n            // find out if we are allowed try to recognize the input for this one.\r\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\r\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\r\n            //      that is being recognized.\r\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\r\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\r\n            if (session.stopped !== FORCED_STOP && ( // 1\r\n                    !curRecognizer || recognizer == curRecognizer || // 2\r\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\r\n                recognizer.recognize(inputData);\r\n            } else {\r\n                recognizer.reset();\r\n            }\r\n\r\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\r\n            // current active recognizer. but only if we don't already have an active recognizer\r\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\r\n                curRecognizer = session.curRecognizer = recognizer;\r\n            }\r\n            i++;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * get a recognizer by its event name.\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Recognizer|Null}\r\n     */\r\n    get: function(recognizer) {\r\n        if (recognizer instanceof Recognizer) {\r\n            return recognizer;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        for (var i = 0; i < recognizers.length; i++) {\r\n            if (recognizers[i].options.event == recognizer) {\r\n                return recognizers[i];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * add a recognizer to the manager\r\n     * existing recognizers with the same event name will be removed\r\n     * @param {Recognizer} recognizer\r\n     * @returns {Recognizer|Manager}\r\n     */\r\n    add: function(recognizer) {\r\n        if (invokeArrayArg(recognizer, 'add', this)) {\r\n            return this;\r\n        }\r\n\r\n        // remove existing\r\n        var existing = this.get(recognizer.options.event);\r\n        if (existing) {\r\n            this.remove(existing);\r\n        }\r\n\r\n        this.recognizers.push(recognizer);\r\n        recognizer.manager = this;\r\n\r\n        this.touchAction.update();\r\n        return recognizer;\r\n    },\r\n\r\n    /**\r\n     * remove a recognizer by name or instance\r\n     * @param {Recognizer|String} recognizer\r\n     * @returns {Manager}\r\n     */\r\n    remove: function(recognizer) {\r\n        if (invokeArrayArg(recognizer, 'remove', this)) {\r\n            return this;\r\n        }\r\n\r\n        var recognizers = this.recognizers;\r\n        recognizer = this.get(recognizer);\r\n        recognizers.splice(inArray(recognizers, recognizer), 1);\r\n\r\n        this.touchAction.update();\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * bind event\r\n     * @param {String} events\r\n     * @param {Function} handler\r\n     * @returns {EventEmitter} this\r\n     */\r\n    on: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            handlers[event] = handlers[event] || [];\r\n            handlers[event].push(handler);\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unbind event, leave emit blank to remove all handlers\r\n     * @param {String} events\r\n     * @param {Function} [handler]\r\n     * @returns {EventEmitter} this\r\n     */\r\n    off: function(events, handler) {\r\n        var handlers = this.handlers;\r\n        each(splitStr(events), function(event) {\r\n            if (!handler) {\r\n                delete handlers[event];\r\n            } else {\r\n                handlers[event].splice(inArray(handlers[event], handler), 1);\r\n            }\r\n        });\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * emit event to the listeners\r\n     * @param {String} event\r\n     * @param {Object} data\r\n     */\r\n    emit: function(event, data) {\r\n        // we also want to trigger dom events\r\n        if (this.options.domEvents) {\r\n            triggerDomEvent(event, data);\r\n        }\r\n\r\n        // no handlers, so skip it all\r\n        var handlers = this.handlers[event] && this.handlers[event].slice();\r\n        if (!handlers || !handlers.length) {\r\n            return;\r\n        }\r\n\r\n        data.type = event;\r\n        data.preventDefault = function() {\r\n            data.srcEvent.preventDefault();\r\n        };\r\n\r\n        var i = 0;\r\n        while (i < handlers.length) {\r\n            handlers[i](data);\r\n            i++;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * destroy the manager and unbinds all events\r\n     * it doesn't unbind dom events, that is the user own responsibility\r\n     */\r\n    destroy: function() {\r\n        this.element && toggleCssProps(this, false);\r\n\r\n        this.handlers = {};\r\n        this.session = {};\r\n        this.input.destroy();\r\n        this.element = null;\r\n    }\r\n};\r\n\r\n/**\r\n * add/remove the css properties as defined in manager.options.cssProps\r\n * @param {Manager} manager\r\n * @param {Boolean} add\r\n */\r\nfunction toggleCssProps(manager, add) {\r\n    var element = manager.element;\r\n    each(manager.options.cssProps, function(value, name) {\r\n        element.style[prefixed(element.style, name)] = add ? value : '';\r\n    });\r\n}\r\n\r\n/**\r\n * trigger dom event\r\n * @param {String} event\r\n * @param {Object} data\r\n */\r\nfunction triggerDomEvent(event, data) {\r\n    var gestureEvent = document.createEvent('Event');\r\n    gestureEvent.initEvent(event, true, true);\r\n    gestureEvent.gesture = data;\r\n    data.target.dispatchEvent(gestureEvent);\r\n}\r\n\r\nextend(Hammer, {\r\n    INPUT_START: INPUT_START,\r\n    INPUT_MOVE: INPUT_MOVE,\r\n    INPUT_END: INPUT_END,\r\n    INPUT_CANCEL: INPUT_CANCEL,\r\n\r\n    STATE_POSSIBLE: STATE_POSSIBLE,\r\n    STATE_BEGAN: STATE_BEGAN,\r\n    STATE_CHANGED: STATE_CHANGED,\r\n    STATE_ENDED: STATE_ENDED,\r\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\r\n    STATE_CANCELLED: STATE_CANCELLED,\r\n    STATE_FAILED: STATE_FAILED,\r\n\r\n    DIRECTION_NONE: DIRECTION_NONE,\r\n    DIRECTION_LEFT: DIRECTION_LEFT,\r\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\r\n    DIRECTION_UP: DIRECTION_UP,\r\n    DIRECTION_DOWN: DIRECTION_DOWN,\r\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\r\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\r\n    DIRECTION_ALL: DIRECTION_ALL,\r\n\r\n    Manager: Manager,\r\n    Input: Input,\r\n    TouchAction: TouchAction,\r\n\r\n    TouchInput: TouchInput,\r\n    MouseInput: MouseInput,\r\n    PointerEventInput: PointerEventInput,\r\n    TouchMouseInput: TouchMouseInput,\r\n    SingleTouchInput: SingleTouchInput,\r\n\r\n    Recognizer: Recognizer,\r\n    AttrRecognizer: AttrRecognizer,\r\n    Tap: TapRecognizer,\r\n    Pan: PanRecognizer,\r\n    Swipe: SwipeRecognizer,\r\n    Pinch: PinchRecognizer,\r\n    Rotate: RotateRecognizer,\r\n    Press: PressRecognizer,\r\n\r\n    on: addEventListeners,\r\n    off: removeEventListeners,\r\n    each: each,\r\n    merge: merge,\r\n    extend: extend,\r\n    inherit: inherit,\r\n    bindFn: bindFn,\r\n    prefixed: prefixed\r\n});\r\n\r\nif (typeof define == TYPE_FUNCTION && define.amd) {\r\n    define(function() {\r\n        return Hammer;\r\n    });\r\n} else if (typeof module != 'undefined' && module.exports) {\r\n    module.exports = Hammer;\r\n} else {\r\n    window[exportName] = Hammer;\r\n}\r\n\r\n})(window, document, 'Hammer');\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}