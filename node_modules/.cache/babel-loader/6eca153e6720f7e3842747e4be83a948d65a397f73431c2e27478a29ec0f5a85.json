{"ast":null,"code":"/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar eventEmitter = require('minimal-event-emitter');\nvar WorkQueue = require('../collections/WorkQueue');\nvar calcRect = require('../util/calcRect');\nvar async = require('../util/async');\nvar cancelize = require('../util/cancelize');\nvar clearOwnProperties = require('../util/clearOwnProperties');\nvar RendererRegistry = require('./RendererRegistry');\nfunction forwardTileCmp(t1, t2) {\n  return t1.cmp(t2);\n}\nfunction reverseTileCmp(t1, t2) {\n  return -t1.cmp(t2);\n}\n\n/**\n * Signals that the stage has been rendered.\n *\n * @param {boolean} stable Whether all tiles were successfully rendered without\n *     missing textures or resorting to fallbacks.\n * @event Stage#renderComplete\n */\n\n/**\n * Signals that the contents of the stage have been invalidated and must be\n * rendered again.\n *\n * This is used by the {@link RenderLoop} implementation.\n *\n * @event Stage#renderInvalid\n */\n\n/**\n * @interface Stage\n * @classdesc\n *\n * A Stage is a container with the ability to render a stack of\n * {@link Layer layers}.\n *\n * This class should never be instantiated directly. Use {@link WebGlStage}\n * instead.\n *\n * @param {Object} opts\n * @param {boolean} [opts.progressive=false]\n *\n * Options listed here may be passed into the `opts` constructor argument of\n * subclasses.\n *\n * The `progressive` option controls whether resolution levels are loaded in\n * order, from lowest to highest. This results in a more pleasing effect when\n * zooming past several levels in a large panoramas, but consumes additional\n * bandwidth.\n */\nfunction Stage(opts) {\n  this._progressive = !!(opts && opts.progressive);\n\n  // The list of layers in display order (background to foreground).\n  this._layers = [];\n\n  // The list of renderers; the i-th renderer is for the i-th layer.\n  this._renderers = [];\n\n  // The lists of tiles to load and render, populated during render().\n  this._tilesToLoad = [];\n  this._tilesToRender = [];\n\n  // Temporary tile lists.\n  this._tmpVisible = [];\n  this._tmpChildren = [];\n\n  // Cached stage dimensions.\n  // Start with zero, which inhibits rendering until setSize() is called.\n  this._width = 0;\n  this._height = 0;\n\n  // Temporary variable for rect.\n  this._tmpRect = {};\n\n  // Temporary variable for size.\n  this._tmpSize = {};\n\n  // Work queue for createTexture.\n  this._createTextureWorkQueue = new WorkQueue();\n\n  // Function to emit event when render parameters have changed.\n  this._emitRenderInvalid = this._emitRenderInvalid.bind(this);\n\n  // The renderer registry maps each geometry/view pair into the respective\n  // Renderer class.\n  this._rendererRegistry = new RendererRegistry();\n}\neventEmitter(Stage);\n\n/**\n * Destructor.\n */\nStage.prototype.destroy = function () {\n  this.removeAllLayers();\n  clearOwnProperties(this);\n};\n\n/**\n * Registers a {@link Renderer} for the given {@link Geometry} and {@link View}\n * type.\n *\n * The {@link registerDefaultRenderers} utility function may be used to\n * register all known renderers for a stage type into that stage. Most users\n * will not need to register renderers, as {@link Viewer} does it for them.\n *\n * @param {string} geometryType The geometry type, as given by\n *     {@link Geometry#type}.\n * @param {string} viewType The view type, as given by {@link View#type}.\n * @param {*} Renderer The renderer class.\n */\nStage.prototype.registerRenderer = function (geometryType, viewType, Renderer) {\n  return this._rendererRegistry.set(geometryType, viewType, Renderer);\n};\n\n/**\n * Returns the underlying DOM element.\n *\n * Must be overridden by subclasses.\n *\n * @return {Element}\n */\nStage.prototype.domElement = function () {\n  throw new Error('Stage implementation must override domElement');\n};\n\n/**\n * Get the stage width.\n * @return {number}\n */\nStage.prototype.width = function () {\n  return this._width;\n};\n\n/**\n * Get the stage height.\n * @return {number}\n */\nStage.prototype.height = function () {\n  return this._height;\n};\n\n/**\n * Get the stage dimensions. If an argument is supplied, it is filled in with\n * the result and returned. Otherwise, a fresh object is filled in and returned.\n *\n * @param {Size=} size\n */\nStage.prototype.size = function (size) {\n  size = size || {};\n  size.width = this._width;\n  size.height = this._height;\n  return size;\n};\n\n/**\n * Set the stage dimensions.\n *\n * This contains the size update logic common to all stage types. Subclasses\n * must define the {@link Stage#setSizeForType} method to perform their own\n * logic.\n *\n * @param {Size} size\n */\nStage.prototype.setSize = function (size) {\n  this._width = size.width;\n  this._height = size.height;\n  this.setSizeForType(); // must be defined by subclasses.\n\n  this.emit('resize');\n  this._emitRenderInvalid();\n};\n\n/**\n * Call {@link Stage#setSize} instead.\n *\n * This contains the size update logic specific to a stage type. It is called by\n * {@link Stage#setSize} after the base class has been updated to reflect the\n * new size, but before any events are emitted.\n *\n * @param {Size} size\n */\nStage.prototype.setSizeForType = function (size) {\n  throw new Error('Stage implementation must override setSizeForType');\n};\n\n/**\n * Loads an {@link Asset} from an image.\n * @param {string} url The image URL.\n * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null\n *     to use the full image.\n * @param {function(?Error, Asset)} done The callback.\n * @return {function()} A function to cancel loading.\n */\nStage.prototype.loadImage = function () {\n  throw new Error('Stage implementation must override loadImage');\n};\nStage.prototype._emitRenderInvalid = function () {\n  this.emit('renderInvalid');\n};\n\n/**\n * Verifies that the layer is valid for this stage, throwing an exception\n * otherwise.\n *\n * @param {Layer} layer\n * @throws {Error} If the layer is not valid for this stage.\n */\nStage.prototype.validateLayer = function (layer) {\n  throw new Error('Stage implementation must override validateLayer');\n};\n\n/**\n * Returns a list of all {@link Layer layers} belonging to the stage. The\n * returned list is in display order, background to foreground.\n * @return {Layer[]}\n */\nStage.prototype.listLayers = function () {\n  // Return a copy to prevent unintended mutation by the caller.\n  return [].concat(this._layers);\n};\n\n/**\n * Return whether a {@link Layer layer} belongs to the stage.\n * @param {Layer} layer\n * @return {boolean}\n */\nStage.prototype.hasLayer = function (layer) {\n  return this._layers.indexOf(layer) >= 0;\n};\n\n/**\n * Adds a {@link Layer layer} into the stage.\n * @param {Layer} layer The layer to add.\n * @param {number|undefined} i The optional position, where 0 ≤ i ≤ n and n is\n *     the current number of layers. The default is n, which inserts at the\n *     top of the display stack.\n * @throws An error if the layer already belongs to the stage or if the position\n *     is invalid.\n */\nStage.prototype.addLayer = function (layer, i) {\n  if (this._layers.indexOf(layer) >= 0) {\n    throw new Error('Layer already in stage');\n  }\n  if (i == null) {\n    i = this._layers.length;\n  }\n  if (i < 0 || i > this._layers.length) {\n    throw new Error('Invalid layer position');\n  }\n  this.validateLayer(layer); // must be defined by subclasses.\n\n  var geometryType = layer.geometry().type;\n  var viewType = layer.view().type;\n  var rendererClass = this._rendererRegistry.get(geometryType, viewType);\n  if (!rendererClass) {\n    throw new Error('No ' + this.type + ' renderer avaiable for ' + geometryType + ' geometry and ' + viewType + ' view');\n  }\n  var renderer = this.createRenderer(rendererClass);\n  this._layers.splice(i, 0, layer);\n  this._renderers.splice(i, 0, renderer);\n\n  // Listeners for render invalid.\n  layer.addEventListener('viewChange', this._emitRenderInvalid);\n  layer.addEventListener('effectsChange', this._emitRenderInvalid);\n  layer.addEventListener('fixedLevelChange', this._emitRenderInvalid);\n  layer.addEventListener('textureStoreChange', this._emitRenderInvalid);\n  this._emitRenderInvalid();\n};\n\n/**\n * Moves a {@link Layer layer} into a different position in the display stack.\n * @param {Layer} layer The layer to move.\n * @param {number} i The position, where 0 ≤ i ≤ n-1 and n is the current number\n *     of layers.\n * @throws An error if the layer does not belong to the stage or if the position\n *     is invalid.\n */\nStage.prototype.moveLayer = function (layer, i) {\n  var index = this._layers.indexOf(layer);\n  if (index < 0) {\n    throw new Error('No such layer in stage');\n  }\n  if (i < 0 || i >= this._layers.length) {\n    throw new Error('Invalid layer position');\n  }\n  layer = this._layers.splice(index, 1)[0];\n  var renderer = this._renderers.splice(index, 1)[0];\n  this._layers.splice(i, 0, layer);\n  this._renderers.splice(i, 0, renderer);\n  this._emitRenderInvalid();\n};\n\n/**\n * Removes a {@link Layer} from the stage.\n * @param {Layer} layer The layer to remove.\n * @throws An error if the layer does not belong to the stage.\n */\nStage.prototype.removeLayer = function (layer) {\n  var index = this._layers.indexOf(layer);\n  if (index < 0) {\n    throw new Error('No such layer in stage');\n  }\n  var removedLayer = this._layers.splice(index, 1)[0];\n  var renderer = this._renderers.splice(index, 1)[0];\n  this.destroyRenderer(renderer);\n  removedLayer.removeEventListener('viewChange', this._emitRenderInvalid);\n  removedLayer.removeEventListener('effectsChange', this._emitRenderInvalid);\n  removedLayer.removeEventListener('fixedLevelChange', this._emitRenderInvalid);\n  removedLayer.removeEventListener('textureStoreChange', this._emitRenderInvalid);\n  this._emitRenderInvalid();\n};\n\n/**\n * Removes all {@link Layer layers} from the stage.\n */\nStage.prototype.removeAllLayers = function () {\n  while (this._layers.length > 0) {\n    this.removeLayer(this._layers[0]);\n  }\n};\n\n/**\n * Called before a frame is rendered.\n *\n * Must be overridden by subclasses.\n */\nStage.prototype.startFrame = function () {\n  throw new Error('Stage implementation must override startFrame');\n};\n\n/**\n * Called after a frame is rendered.\n *\n * Must be overridden by subclasses.\n */\nStage.prototype.endFrame = function () {\n  throw new Error('Stage implementation must override endFrame');\n};\n\n/**\n * Render the current frame. Usually called from a {@link RenderLoop}.\n *\n * This contains the rendering logic common to all stage types. Subclasses\n * define the startFrame() and endFrame() methods to perform their own logic.\n */\nStage.prototype.render = function () {\n  var i, j;\n  var tilesToLoad = this._tilesToLoad;\n  var tilesToRender = this._tilesToRender;\n  var stableStage = true;\n  var stableLayer;\n\n  // Get the stage dimensions.\n  var width = this._width;\n  var height = this._height;\n  var rect = this._tmpRect;\n  var size = this._tmpSize;\n  if (width <= 0 || height <= 0) {\n    return;\n  }\n  this.startFrame(); // defined by subclasses\n\n  // Signal start of frame to the texture stores.\n  for (i = 0; i < this._layers.length; i++) {\n    this._layers[i].textureStore().startFrame();\n  }\n\n  // Render layers.\n  for (i = 0; i < this._layers.length; i++) {\n    var layer = this._layers[i];\n    var effects = layer.effects();\n    var view = layer.view();\n    var textureStore = layer.textureStore();\n    var renderer = this._renderers[i];\n    var depth = this._layers.length - i;\n    var tile, texture;\n\n    // Convert the rect effect into a normalized rect.\n    // TODO: avoid doing this on every frame.\n    calcRect(width, height, effects && effects.rect, rect);\n    if (rect.width <= 0 || rect.height <= 0) {\n      // Skip rendering on a null viewport.\n      continue;\n    }\n\n    // Update the view size.\n    size.width = rect.width * this._width;\n    size.height = rect.height * this._height;\n    view.setSize(size);\n\n    // Signal start of layer to the renderer.\n    renderer.startLayer(layer, rect);\n\n    // We render with both alpha blending and depth testing enabled. Thus, when\n    // rendering a subsequent pixel at the same location than an existing one,\n    // the subsequent pixel gets discarded unless it has smaller depth, and is\n    // otherwise composited with the existing pixel.\n    //\n    // When using fallback tiles to fill a gap in the preferred resolution\n    // level, we prefer higher resolution fallbacks to lower resolution ones.\n    // However, where fallbacks overlap, we want higher resolution ones to\n    // prevail, and we don't want multiple fallbacks to be composited with each\n    // other, as that would produce a bad result when semitransparent textures\n    // are involved.\n    //\n    // In order to achieve this within the constraints of alpha blending and\n    // depth testing, the depth of a tile must be inversely proportional to its\n    // resolution, and higher-resolution tiles must be rendered before lower-\n    // resolution ones.\n\n    // Collect the lists of tiles to load and render.\n    stableLayer = this._collectTiles(layer, textureStore);\n\n    // Mark all the tiles whose textures must be loaded.\n    // This will either trigger loading (for textures not yet loaded) or\n    // prevent unloading (for textures already loaded).\n    for (j = 0; j < tilesToLoad.length; j++) {\n      tile = tilesToLoad[j];\n      textureStore.markTile(tile);\n    }\n\n    // Render tiles.\n    for (j = 0; j < tilesToRender.length; j++) {\n      tile = tilesToRender[j];\n      texture = textureStore.texture(tile);\n      renderer.renderTile(tile, texture, layer, depth);\n    }\n    layer.emit('renderComplete', stableLayer);\n    if (!stableLayer) {\n      stableStage = false;\n    }\n\n    // Signal end of layer to the renderer.\n    renderer.endLayer(layer, rect);\n  }\n\n  // Signal end of frame to the texture stores.\n  for (i = 0; i < this._layers.length; i++) {\n    this._layers[i].textureStore().endFrame();\n  }\n  this.endFrame(); // defined by subclasses\n\n  this.emit('renderComplete', stableStage);\n};\nStage.prototype._collectTiles = function (layer, textureStore) {\n  var tilesToLoad = this._tilesToLoad;\n  var tilesToRender = this._tilesToRender;\n  var tmpVisible = this._tmpVisible;\n  tilesToLoad.length = 0;\n  tilesToRender.length = 0;\n  tmpVisible.length = 0;\n  layer.visibleTiles(tmpVisible);\n  var isStable = true;\n  for (var i = 0; i < tmpVisible.length; i++) {\n    var tile = tmpVisible[i];\n    var needsFallback;\n    this._collectTileToLoad(tile);\n    if (textureStore.texture(tile)) {\n      // The preferred texture is available.\n      // No fallback is required.\n      needsFallback = false;\n      this._collectTileToRender(tile);\n    } else {\n      // The preferred texture is unavailable.\n      // Collect children for rendering as a fallback.\n      needsFallback = this._collectChildren(tile, textureStore);\n      isStable = false;\n    }\n    // Collect all parents for loading, and the closest parent for rendering if\n    // a fallback is required.\n    this._collectParents(tile, textureStore, needsFallback);\n  }\n\n  // Sort tiles to load in ascending resolution order.\n  tilesToLoad.sort(forwardTileCmp);\n\n  // Sort tiles to render in descending resolution order.\n  tilesToRender.sort(reverseTileCmp);\n  return isStable;\n};\nStage.prototype._collectChildren = function (tile, textureStore) {\n  var tmpChildren = this._tmpChildren;\n  var needsFallback = true;\n\n  // Fall back as many levels as necessary on single-child geometries, but do\n  // not go beyond immediate children on multiple-child geometries, to avoid\n  // exploring an exponential number of tiles.\n  do {\n    tmpChildren.length = 0;\n    if (!tile.children(tmpChildren)) {\n      break;\n    }\n    needsFallback = false;\n    for (var i = 0; i < tmpChildren.length; i++) {\n      tile = tmpChildren[i];\n      if (textureStore.texture(tile)) {\n        this._collectTileToLoad(tile);\n        this._collectTileToRender(tile);\n      } else {\n        needsFallback = true;\n      }\n    }\n  } while (needsFallback && tmpChildren.length === 1);\n  return needsFallback;\n};\nStage.prototype._collectParents = function (tile, textureStore, needsFallback) {\n  // Recursively visit parent tiles until:\n  //   - all parents have been marked for loading, if progressive rendering is\n  //     enabled; and\n  //   - at least one parent has been marked for both loading and rendering, if\n  //     a fallback is required.\n  var needsLoading = this._progressive;\n  while ((needsLoading || needsFallback) && (tile = tile.parent()) != null) {\n    if (needsFallback) {\n      if (textureStore.texture(tile)) {\n        this._collectTileToRender(tile);\n        needsFallback = false;\n      } else if (!this._progressive) {\n        continue;\n      }\n    }\n    if (!this._collectTileToLoad(tile)) {\n      needsLoading = false;\n    }\n  }\n  return needsFallback;\n};\nStage.prototype._collectTileToLoad = function (tile) {\n  return this._collectTileIntoList(tile, this._tilesToLoad);\n};\nStage.prototype._collectTileToRender = function (tile) {\n  return this._collectTileIntoList(tile, this._tilesToRender);\n};\nStage.prototype._collectTileIntoList = function (tile, tileList) {\n  // TODO: Investigate whether it's worth it to make this better than O(n²).\n  var found = false;\n  for (var i = 0; i < tileList.length; i++) {\n    if (tile.equals(tileList[i])) {\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    tileList.push(tile);\n  }\n  return !found;\n};\n\n/**\n * Create a texture for the given tile and asset. Called by {@link TextureStore}.\n * @param {Tile} tile\n * @param {Asset} asset\n * @param {Function} done\n */\nStage.prototype.createTexture = function (tile, asset, done) {\n  var self = this;\n  function makeTexture() {\n    return new self.TextureClass(self, tile, asset);\n  }\n  var fn = cancelize(async(makeTexture));\n  return this._createTextureWorkQueue.push(fn, function (err, texture) {\n    done(err, tile, asset, texture);\n  });\n};\n\n/**\n * The stage type, used to determine the appropriate renderer for a given\n * geometry and view.\n *\n * The sole known value is `\"webgl\".\n *\n * See also {@link Stage#registerRenderer}.\n *\n * @property {string}\n * @name Stage#type\n */\n\nmodule.exports = Stage;","map":{"version":3,"names":["eventEmitter","require","WorkQueue","calcRect","async","cancelize","clearOwnProperties","RendererRegistry","forwardTileCmp","t1","t2","cmp","reverseTileCmp","Stage","opts","_progressive","progressive","_layers","_renderers","_tilesToLoad","_tilesToRender","_tmpVisible","_tmpChildren","_width","_height","_tmpRect","_tmpSize","_createTextureWorkQueue","_emitRenderInvalid","bind","_rendererRegistry","prototype","destroy","removeAllLayers","registerRenderer","geometryType","viewType","Renderer","set","domElement","Error","width","height","size","setSize","setSizeForType","emit","loadImage","validateLayer","layer","listLayers","concat","hasLayer","indexOf","addLayer","i","length","geometry","type","view","rendererClass","get","renderer","createRenderer","splice","addEventListener","moveLayer","index","removeLayer","removedLayer","destroyRenderer","removeEventListener","startFrame","endFrame","render","j","tilesToLoad","tilesToRender","stableStage","stableLayer","rect","textureStore","effects","depth","tile","texture","startLayer","_collectTiles","markTile","renderTile","endLayer","tmpVisible","visibleTiles","isStable","needsFallback","_collectTileToLoad","_collectTileToRender","_collectChildren","_collectParents","sort","tmpChildren","children","needsLoading","parent","_collectTileIntoList","tileList","found","equals","push","createTexture","asset","done","self","makeTexture","TextureClass","fn","err","module","exports"],"sources":["E:/VR/node_modules/marzipano/src/stages/Stage.js"],"sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar eventEmitter = require('minimal-event-emitter');\nvar WorkQueue = require('../collections/WorkQueue');\nvar calcRect = require('../util/calcRect');\nvar async = require('../util/async');\nvar cancelize = require('../util/cancelize');\nvar clearOwnProperties = require('../util/clearOwnProperties');\n\nvar RendererRegistry = require('./RendererRegistry');\n\nfunction forwardTileCmp(t1, t2) {\n  return t1.cmp(t2);\n}\n\nfunction reverseTileCmp(t1, t2) {\n  return -t1.cmp(t2);\n}\n\n/**\n * Signals that the stage has been rendered.\n *\n * @param {boolean} stable Whether all tiles were successfully rendered without\n *     missing textures or resorting to fallbacks.\n * @event Stage#renderComplete\n */\n\n/**\n * Signals that the contents of the stage have been invalidated and must be\n * rendered again.\n *\n * This is used by the {@link RenderLoop} implementation.\n *\n * @event Stage#renderInvalid\n */\n\n/**\n * @interface Stage\n * @classdesc\n *\n * A Stage is a container with the ability to render a stack of\n * {@link Layer layers}.\n *\n * This class should never be instantiated directly. Use {@link WebGlStage}\n * instead.\n *\n * @param {Object} opts\n * @param {boolean} [opts.progressive=false]\n *\n * Options listed here may be passed into the `opts` constructor argument of\n * subclasses.\n *\n * The `progressive` option controls whether resolution levels are loaded in\n * order, from lowest to highest. This results in a more pleasing effect when\n * zooming past several levels in a large panoramas, but consumes additional\n * bandwidth.\n */\nfunction Stage(opts) {\n  this._progressive = !!(opts && opts.progressive);\n\n  // The list of layers in display order (background to foreground).\n  this._layers = [];\n\n  // The list of renderers; the i-th renderer is for the i-th layer.\n  this._renderers = [];\n\n  // The lists of tiles to load and render, populated during render().\n  this._tilesToLoad = [];\n  this._tilesToRender = [];\n\n  // Temporary tile lists.\n  this._tmpVisible = [];\n  this._tmpChildren = [];\n\n  // Cached stage dimensions.\n  // Start with zero, which inhibits rendering until setSize() is called.\n  this._width = 0;\n  this._height = 0;\n\n  // Temporary variable for rect.\n  this._tmpRect = {};\n\n  // Temporary variable for size.\n  this._tmpSize = {};\n\n  // Work queue for createTexture.\n  this._createTextureWorkQueue = new WorkQueue();\n\n  // Function to emit event when render parameters have changed.\n  this._emitRenderInvalid = this._emitRenderInvalid.bind(this);\n\n  // The renderer registry maps each geometry/view pair into the respective\n  // Renderer class.\n  this._rendererRegistry = new RendererRegistry();\n}\n\neventEmitter(Stage);\n\n\n/**\n * Destructor.\n */\nStage.prototype.destroy = function() {\n  this.removeAllLayers();\n  clearOwnProperties(this);\n};\n\n\n/**\n * Registers a {@link Renderer} for the given {@link Geometry} and {@link View}\n * type.\n *\n * The {@link registerDefaultRenderers} utility function may be used to\n * register all known renderers for a stage type into that stage. Most users\n * will not need to register renderers, as {@link Viewer} does it for them.\n *\n * @param {string} geometryType The geometry type, as given by\n *     {@link Geometry#type}.\n * @param {string} viewType The view type, as given by {@link View#type}.\n * @param {*} Renderer The renderer class.\n */\nStage.prototype.registerRenderer = function(geometryType, viewType, Renderer) {\n  return this._rendererRegistry.set(geometryType, viewType, Renderer);\n};\n\n\n/**\n * Returns the underlying DOM element.\n *\n * Must be overridden by subclasses.\n *\n * @return {Element}\n */\nStage.prototype.domElement = function() {\n  throw new Error('Stage implementation must override domElement');\n};\n\n\n/**\n * Get the stage width.\n * @return {number}\n */\nStage.prototype.width = function() {\n  return this._width;\n};\n\n\n/**\n * Get the stage height.\n * @return {number}\n */\nStage.prototype.height = function() {\n  return this._height;\n};\n\n\n/**\n * Get the stage dimensions. If an argument is supplied, it is filled in with\n * the result and returned. Otherwise, a fresh object is filled in and returned.\n *\n * @param {Size=} size\n */\nStage.prototype.size = function(size) {\n  size = size || {};\n  size.width = this._width;\n  size.height = this._height;\n  return size;\n};\n\n\n/**\n * Set the stage dimensions.\n *\n * This contains the size update logic common to all stage types. Subclasses\n * must define the {@link Stage#setSizeForType} method to perform their own\n * logic.\n *\n * @param {Size} size\n */\nStage.prototype.setSize = function(size) {\n  this._width = size.width;\n  this._height = size.height;\n\n  this.setSizeForType(); // must be defined by subclasses.\n\n  this.emit('resize');\n  this._emitRenderInvalid();\n};\n\n\n/**\n * Call {@link Stage#setSize} instead.\n *\n * This contains the size update logic specific to a stage type. It is called by\n * {@link Stage#setSize} after the base class has been updated to reflect the\n * new size, but before any events are emitted.\n *\n * @param {Size} size\n */\nStage.prototype.setSizeForType = function(size) {\n  throw new Error('Stage implementation must override setSizeForType');\n};\n\n\n/**\n * Loads an {@link Asset} from an image.\n * @param {string} url The image URL.\n * @param {?Rect} rect A {@link Rect} describing a portion of the image, or null\n *     to use the full image.\n * @param {function(?Error, Asset)} done The callback.\n * @return {function()} A function to cancel loading.\n */\nStage.prototype.loadImage = function() {\n  throw new Error('Stage implementation must override loadImage');\n};\n\n\nStage.prototype._emitRenderInvalid = function() {\n  this.emit('renderInvalid');\n};\n\n\n/**\n * Verifies that the layer is valid for this stage, throwing an exception\n * otherwise.\n *\n * @param {Layer} layer\n * @throws {Error} If the layer is not valid for this stage.\n */\nStage.prototype.validateLayer = function(layer) {\n  throw new Error('Stage implementation must override validateLayer');\n};\n\n\n/**\n * Returns a list of all {@link Layer layers} belonging to the stage. The\n * returned list is in display order, background to foreground.\n * @return {Layer[]}\n */\nStage.prototype.listLayers = function() {\n  // Return a copy to prevent unintended mutation by the caller.\n  return [].concat(this._layers);\n};\n\n\n/**\n * Return whether a {@link Layer layer} belongs to the stage.\n * @param {Layer} layer\n * @return {boolean}\n */\nStage.prototype.hasLayer = function(layer) {\n  return this._layers.indexOf(layer) >= 0;\n};\n\n\n/**\n * Adds a {@link Layer layer} into the stage.\n * @param {Layer} layer The layer to add.\n * @param {number|undefined} i The optional position, where 0 ≤ i ≤ n and n is\n *     the current number of layers. The default is n, which inserts at the\n *     top of the display stack.\n * @throws An error if the layer already belongs to the stage or if the position\n *     is invalid.\n */\nStage.prototype.addLayer = function(layer, i) {\n  if (this._layers.indexOf(layer) >= 0) {\n    throw new Error('Layer already in stage');\n  }\n\n  if (i == null) {\n    i = this._layers.length;\n  }\n  if (i < 0 || i > this._layers.length) {\n    throw new Error('Invalid layer position');\n  }\n\n  this.validateLayer(layer); // must be defined by subclasses.\n\n  var geometryType = layer.geometry().type;\n  var viewType = layer.view().type;\n  var rendererClass = this._rendererRegistry.get(geometryType, viewType);\n  if (!rendererClass) {\n    throw new Error('No ' + this.type + ' renderer avaiable for ' +\n        geometryType + ' geometry and ' + viewType + ' view');\n  }\n  var renderer = this.createRenderer(rendererClass);\n\n  this._layers.splice(i, 0, layer);\n  this._renderers.splice(i, 0, renderer);\n\n  // Listeners for render invalid.\n  layer.addEventListener('viewChange', this._emitRenderInvalid);\n  layer.addEventListener('effectsChange', this._emitRenderInvalid);\n  layer.addEventListener('fixedLevelChange', this._emitRenderInvalid);\n  layer.addEventListener('textureStoreChange', this._emitRenderInvalid);\n\n  this._emitRenderInvalid();\n};\n\n\n/**\n * Moves a {@link Layer layer} into a different position in the display stack.\n * @param {Layer} layer The layer to move.\n * @param {number} i The position, where 0 ≤ i ≤ n-1 and n is the current number\n *     of layers.\n * @throws An error if the layer does not belong to the stage or if the position\n *     is invalid.\n */\nStage.prototype.moveLayer = function(layer, i) {\n  var index = this._layers.indexOf(layer);\n  if (index < 0) {\n    throw new Error('No such layer in stage');\n  }\n\n  if (i < 0 || i >= this._layers.length) {\n    throw new Error('Invalid layer position');\n  }\n\n  layer = this._layers.splice(index, 1)[0];\n  var renderer = this._renderers.splice(index, 1)[0];\n\n  this._layers.splice(i, 0, layer);\n  this._renderers.splice(i, 0, renderer);\n\n  this._emitRenderInvalid();\n};\n\n\n/**\n * Removes a {@link Layer} from the stage.\n * @param {Layer} layer The layer to remove.\n * @throws An error if the layer does not belong to the stage.\n */\nStage.prototype.removeLayer = function(layer) {\n  var index = this._layers.indexOf(layer);\n  if (index < 0) {\n    throw new Error('No such layer in stage');\n  }\n\n  var removedLayer = this._layers.splice(index, 1)[0];\n  var renderer = this._renderers.splice(index, 1)[0];\n\n  this.destroyRenderer(renderer);\n\n  removedLayer.removeEventListener('viewChange', this._emitRenderInvalid);\n  removedLayer.removeEventListener('effectsChange', this._emitRenderInvalid);\n  removedLayer.removeEventListener('fixedLevelChange', this._emitRenderInvalid);\n  removedLayer.removeEventListener('textureStoreChange', this._emitRenderInvalid);\n\n  this._emitRenderInvalid();\n};\n\n\n/**\n * Removes all {@link Layer layers} from the stage.\n */\nStage.prototype.removeAllLayers = function() {\n  while (this._layers.length > 0) {\n    this.removeLayer(this._layers[0]);\n  }\n};\n\n\n/**\n * Called before a frame is rendered.\n *\n * Must be overridden by subclasses.\n */\nStage.prototype.startFrame = function() {\n  throw new Error('Stage implementation must override startFrame');\n};\n\n\n/**\n * Called after a frame is rendered.\n *\n * Must be overridden by subclasses.\n */\nStage.prototype.endFrame = function() {\n  throw new Error('Stage implementation must override endFrame');\n};\n\n\n/**\n * Render the current frame. Usually called from a {@link RenderLoop}.\n *\n * This contains the rendering logic common to all stage types. Subclasses\n * define the startFrame() and endFrame() methods to perform their own logic.\n */\nStage.prototype.render = function() {\n  var i, j;\n\n  var tilesToLoad = this._tilesToLoad;\n  var tilesToRender = this._tilesToRender;\n\n  var stableStage = true;\n  var stableLayer;\n\n  // Get the stage dimensions.\n  var width = this._width;\n  var height = this._height;\n\n  var rect = this._tmpRect;\n  var size = this._tmpSize;\n\n  if (width <= 0 || height <= 0) {\n    return;\n  }\n\n  this.startFrame(); // defined by subclasses\n\n  // Signal start of frame to the texture stores.\n  for (i = 0; i < this._layers.length; i++) {\n    this._layers[i].textureStore().startFrame();\n  }\n\n  // Render layers.\n  for (i = 0; i < this._layers.length; i++) {\n    var layer = this._layers[i];\n    var effects = layer.effects();\n    var view = layer.view();\n    var textureStore = layer.textureStore();\n    var renderer = this._renderers[i];\n    var depth = this._layers.length - i;\n    var tile, texture;\n\n    // Convert the rect effect into a normalized rect.\n    // TODO: avoid doing this on every frame.\n    calcRect(width, height, effects && effects.rect, rect);\n\n    if (rect.width <= 0 || rect.height <= 0) {\n      // Skip rendering on a null viewport.\n      continue;\n    }\n\n    // Update the view size.\n    size.width = rect.width * this._width;\n    size.height = rect.height * this._height;\n    view.setSize(size);\n\n    // Signal start of layer to the renderer.\n    renderer.startLayer(layer, rect);\n\n    // We render with both alpha blending and depth testing enabled. Thus, when\n    // rendering a subsequent pixel at the same location than an existing one,\n    // the subsequent pixel gets discarded unless it has smaller depth, and is\n    // otherwise composited with the existing pixel.\n    //\n    // When using fallback tiles to fill a gap in the preferred resolution\n    // level, we prefer higher resolution fallbacks to lower resolution ones.\n    // However, where fallbacks overlap, we want higher resolution ones to\n    // prevail, and we don't want multiple fallbacks to be composited with each\n    // other, as that would produce a bad result when semitransparent textures\n    // are involved.\n    //\n    // In order to achieve this within the constraints of alpha blending and\n    // depth testing, the depth of a tile must be inversely proportional to its\n    // resolution, and higher-resolution tiles must be rendered before lower-\n    // resolution ones.\n\n    // Collect the lists of tiles to load and render.\n    stableLayer = this._collectTiles(layer, textureStore);\n\n    // Mark all the tiles whose textures must be loaded.\n    // This will either trigger loading (for textures not yet loaded) or\n    // prevent unloading (for textures already loaded).\n    for (j = 0; j < tilesToLoad.length; j++) {\n      tile = tilesToLoad[j];\n      textureStore.markTile(tile);\n    }\n\n    // Render tiles.\n    for (j = 0; j < tilesToRender.length; j++) {\n      tile = tilesToRender[j];\n      texture = textureStore.texture(tile);\n      renderer.renderTile(tile, texture, layer, depth);\n    }\n\n    layer.emit('renderComplete', stableLayer);\n    if (!stableLayer) {\n      stableStage = false;\n    }\n\n    // Signal end of layer to the renderer.\n    renderer.endLayer(layer, rect);\n  }\n\n  // Signal end of frame to the texture stores.\n  for (i = 0; i < this._layers.length; i++) {\n    this._layers[i].textureStore().endFrame();\n  }\n\n  this.endFrame(); // defined by subclasses\n\n  this.emit('renderComplete', stableStage);\n};\n\nStage.prototype._collectTiles = function(layer, textureStore) {\n  var tilesToLoad = this._tilesToLoad;\n  var tilesToRender = this._tilesToRender;\n  var tmpVisible = this._tmpVisible;\n\n  tilesToLoad.length = 0;\n  tilesToRender.length = 0;\n  tmpVisible.length = 0;\n\n  layer.visibleTiles(tmpVisible);\n\n  var isStable = true;\n\n  for (var i = 0; i < tmpVisible.length; i++) {\n    var tile = tmpVisible[i];\n    var needsFallback;\n    this._collectTileToLoad(tile);\n    if (textureStore.texture(tile)) {\n      // The preferred texture is available.\n      // No fallback is required.\n      needsFallback = false;\n      this._collectTileToRender(tile);\n    } else {\n      // The preferred texture is unavailable.\n      // Collect children for rendering as a fallback.\n      needsFallback = this._collectChildren(tile, textureStore);\n      isStable = false;\n    }\n    // Collect all parents for loading, and the closest parent for rendering if\n    // a fallback is required.\n    this._collectParents(tile, textureStore, needsFallback);\n  }\n\n  // Sort tiles to load in ascending resolution order.\n  tilesToLoad.sort(forwardTileCmp);\n\n  // Sort tiles to render in descending resolution order.\n  tilesToRender.sort(reverseTileCmp);\n\n  return isStable;\n};\n\nStage.prototype._collectChildren = function(tile, textureStore) {\n  var tmpChildren = this._tmpChildren;\n\n  var needsFallback = true;\n\n  // Fall back as many levels as necessary on single-child geometries, but do\n  // not go beyond immediate children on multiple-child geometries, to avoid\n  // exploring an exponential number of tiles.\n  do {\n    tmpChildren.length = 0;\n    if (!tile.children(tmpChildren)) {\n      break;\n    }\n    needsFallback = false;\n    for (var i = 0; i < tmpChildren.length; i++) {\n      tile = tmpChildren[i];\n      if (textureStore.texture(tile)) {\n        this._collectTileToLoad(tile);\n        this._collectTileToRender(tile);\n      } else {\n        needsFallback = true;\n      }\n    }\n  } while (needsFallback && tmpChildren.length === 1)\n\n  return needsFallback;\n};\n\nStage.prototype._collectParents = function(tile, textureStore, needsFallback) {\n  // Recursively visit parent tiles until:\n  //   - all parents have been marked for loading, if progressive rendering is\n  //     enabled; and\n  //   - at least one parent has been marked for both loading and rendering, if\n  //     a fallback is required.\n  var needsLoading = this._progressive;\n  while ((needsLoading || needsFallback) && (tile = tile.parent()) != null) {\n    if (needsFallback) {\n      if (textureStore.texture(tile)) {\n        this._collectTileToRender(tile);\n        needsFallback = false;\n      } else if (!this._progressive) {\n        continue;\n      }\n    }\n    if (!this._collectTileToLoad(tile)) {\n      needsLoading = false;\n    }\n  }\n  return needsFallback;\n};\n\nStage.prototype._collectTileToLoad = function(tile) {\n  return this._collectTileIntoList(tile, this._tilesToLoad);\n};\n\nStage.prototype._collectTileToRender = function(tile) {\n  return this._collectTileIntoList(tile, this._tilesToRender);\n};\n\nStage.prototype._collectTileIntoList = function(tile, tileList) {\n  // TODO: Investigate whether it's worth it to make this better than O(n²).\n  var found = false;\n  for (var i = 0; i < tileList.length; i++) {\n    if (tile.equals(tileList[i])) {\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    tileList.push(tile);\n  }\n  return !found;\n};\n\n/**\n * Create a texture for the given tile and asset. Called by {@link TextureStore}.\n * @param {Tile} tile\n * @param {Asset} asset\n * @param {Function} done\n */\nStage.prototype.createTexture = function(tile, asset, done) {\n\n  var self = this;\n\n  function makeTexture() {\n    return new self.TextureClass(self, tile, asset);\n  }\n\n  var fn = cancelize(async(makeTexture));\n\n  return this._createTextureWorkQueue.push(fn, function(err, texture) {\n    done(err, tile, asset, texture);\n  });\n\n};\n\n/**\n * The stage type, used to determine the appropriate renderer for a given\n * geometry and view.\n *\n * The sole known value is `\"webgl\".\n *\n * See also {@link Stage#registerRenderer}.\n *\n * @property {string}\n * @name Stage#type\n */\n\nmodule.exports = Stage;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}